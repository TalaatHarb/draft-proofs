/-
# Numerical Analysis: The Bisection Method

This file develops the classical **bisection root-finding method** for continuous
real functions. It contains:

* A definition of a single bisection step
* The recursive sequence of bisection intervals
* Midpoints of these intervals
* A proof that interval lengths shrink to zero
* Convergence of the midpoint sequence to a root
* A quantitative error bound after `n` iterations

This is structured according to mathlib conventions and is intended as a starting
point for a full formalization.
-/

import Mathlib.Topology.Basic
import Mathlib.Data.Real.Basic
import Mathlib.Analysis.Calculus.MeanValue
import Mathlib.Analysis.SpecialFunctions.Pow.Real

open scoped Topology
open Filter

noncomputable section

namespace Numerical

structure Interval where
  a : â„
  b : â„
  h : a â‰¤ b

@[simp] def midpoint (I : Interval) : â„ := (I.a + I.b) / 2

def IccOfInterval (I : Interval) : Set â„ := Set.Icc I.a I.b

/-! ## Bisection Step -/

/-- A single bisection step: given a function `f` and an interval `[a, b]`
with a sign change, return the next subinterval containing the root. -/
def bisectionStep (f : â„ â†’ â„) (I : Interval) : Interval :=
  if h : f I.a * f (midpoint I) â‰¤ 0 then
    { a := I.a, b := (midpoint I), h : I.a â‰¤ (midpoint I) := by simp; linarith[I.h] }
  else
    { a := (midpoint I), b := I.b, h : (midpoint I) â‰¤ I.b := by simp; linarith[I.h] }

/-- Length of a real interval. -/
@[simp] def intervalLength (I : Interval) : â„ := I.b - I.a

/-! ## Recursive interval sequence -/

/-- The `n`-th interval generated by the bisection method. -/
def bisectionInterval (f : â„ â†’ â„) : â„• â†’ Interval â†’ Interval
  | 0,   I  => I
  | n+1, I  =>
      let next := bisectionStep f I
      bisectionInterval f n next

/-- The midpoint of the `n`-th bisection interval. -/
def bisectionMidpoint (f : â„ â†’ â„) (I : Interval) (n : â„•) : â„ :=
  let In := bisectionInterval f n I
  (In.a + In.b) / 2


/-! ## Interval-shrinking lemmas -/

section IntervalShrink

lemma interval_left_le_midpoint (I: Interval) : I.a â‰¤ midpoint I := by
  simp
  linarith [I.h]

lemma interval_midpoint_le_right (I: Interval) : midpoint I â‰¤ I.b := by
  simp
  linarith [I.h]

/-- The interval length after one bisection step is half the original. -/
lemma intervalLength_bisectionStep (f : â„ â†’ â„) (I: Interval):
    intervalLength (bisectionStep f I) = (I.b - I.a) / 2 := by
  dsimp [bisectionStep, intervalLength]
  by_cases h : f I.a * f (midpoint I) â‰¤ 0
  all_goals
  Â· split
    all_goals
    ring_nf


lemma intervalLength_bisectionInterval (f : â„ â†’ â„) (I : Interval) :
  âˆ€ n : â„•, intervalLength (bisectionInterval f n I) = intervalLength I / 2^n
:= by
  intro n
  induction n generalizing I with
  | zero => simp [bisectionInterval, intervalLength, pow_zero]
  | succ n ih =>
    -- let J be the interval after one bisection step
    let J := bisectionStep f I
    -- Apply the inductive hypothesis to J (not I!)
    have ihJ : intervalLength (bisectionInterval f n J) = intervalLength J / 2^n := by exact ih J
    simp only [bisectionInterval]
    rw [ihJ]
    -- Now we need: intervalLength J / 2^n = intervalLength (a, b) / 2^(n+1)
    rw [intervalLength_bisectionStep]
    -- We have: ((b - a) / 2) / 2^n = (b - a) / 2^(n+1)
    simp [intervalLength, pow_succ]
    ring_nf



/-- The interval diameters tend to zero as `n â†’ âˆž`. -/
lemma diam_tendsto_zero (f : â„ â†’ â„) (I : Interval) :
  Tendsto (fun n => intervalLength (bisectionInterval f n I))
          atTop (ð“ 0) := by
  simp_rw [intervalLength_bisectionInterval]
  have hs : (fun n => intervalLength I / 2 ^ n) = 
         (fun n => intervalLength I * (1 / 2) ^ n) := by
    ext n
    simp
    ring_nf
  rw [hs]
  have hpow : Tendsto (fun n => (1 / 2 : â„) ^ n) atTop (ð“ 0) := by
    apply tendsto_pow_atTop_nhds_zero_of_lt_one
    Â· norm_num
    Â· norm_num
  convert Tendsto.const_mul (intervalLength I) hpow using 1
  simp

end IntervalShrink


/-! ## Convergence of the bisection method -/

section Convergence

/-- Helper lemma: midpoints of nested intervals stay within bounds -/
lemma midpoint_in_interval (f : â„ â†’ â„) (I : Interval) (n : â„•) :
    have {a:= aâ‚€, b:= bâ‚€, h:= _} := I
    have {a:= aâ‚™, b:= bâ‚™, h:= _} := bisectionInterval f n I
    aâ‚€ â‰¤ aâ‚™ âˆ§ aâ‚™ â‰¤ bâ‚™ âˆ§ bâ‚™ â‰¤ bâ‚€ := by
    constructor
    . induction n generalizing I with
      | zero => simp [bisectionInterval]
      | succ n ih => 
      simp [bisectionInterval]
      . have ihJ := ih (bisectionStep f I)
        have hi : I.a â‰¤ (bisectionStep f I).a := by      
          -- bisection always shrinks toward the middle:
          -- The new 'a' is either I.a or midpoint(I), both â‰¥ I.a
          rw [bisectionStep]
          by_cases hfp : f I.a * f (midpoint I) â‰¤ 0
          Â· -- left interval: new a = old a
            split
            . simp
            . contradiction
          Â· -- right interval: new a = midpoint â‰¥ a
            split
            . contradiction
            . simp; linarith [I.h]
        apply le_trans hi
        exact ihJ
    . constructor
      . exact (bisectionInterval f n I).h
      . induction n generalizing I with
      | zero => simp [bisectionInterval]
      | succ n ih => 
      simp [bisectionInterval]
      . have ihJ := ih (bisectionStep f I)
        have hi :  (bisectionStep f I).b â‰¤ I.b := by      
          -- bisection always shrinks toward the middle:
          -- The new 'a' is either I.a or midpoint(I), both â‰¥ I.a
          rw [bisectionStep]
          by_cases hfp : f I.a * f (midpoint I) â‰¤ 0
          Â· -- left interval: new a = old a
            split
            . simp; linarith [I.h]
            . contradiction
          Â· -- right interval: new a = midpoint â‰¥ a
            split
            . contradiction
            . simp
        apply le_trans ihJ
        exact hi

/-- The interval produced by one bisection step is contained in the original interval. -/
lemma bisectionStep_subset (f : â„ â†’ â„) (I : Interval) :
  IccOfInterval (bisectionStep f I) âŠ† IccOfInterval I := by
  -- expand definitions and do a case split on the `if` in `bisectionStep`
  dsimp [bisectionStep, IccOfInterval, midpoint]
  by_cases h : f I.a * f (midpoint I) â‰¤ 0
  Â· -- left branch: interval is [I.a, m]
    split
    . -- show {x | I.a â‰¤ x âˆ§ x â‰¤ m} âŠ† {x | I.a â‰¤ x âˆ§ x â‰¤ I.b}
      intro x hx
      exact âŸ¨hx.1, le_trans hx.2 (interval_midpoint_le_right I)âŸ©
    . -- show {x | I.a â‰¤ x âˆ§ x â‰¤ m} âŠ† {x | I.a â‰¤ x âˆ§ x â‰¤ I.b}
      intro x hx
      exact âŸ¨le_trans (interval_left_le_midpoint I) hx.1, hx.2âŸ©
  Â· -- right branch: interval is [m, I.b]
    split
    . -- show {x | I.a â‰¤ x âˆ§ x â‰¤ m} âŠ† {x | I.a â‰¤ x âˆ§ x â‰¤ I.b}
      intro x hx
      exact âŸ¨hx.1, le_trans hx.2 (interval_midpoint_le_right I)âŸ©
    . -- show {x | I.a â‰¤ x âˆ§ x â‰¤ m} âŠ† {x | I.a â‰¤ x âˆ§ x â‰¤ I.b}
      intro x hx
      exact âŸ¨le_trans (interval_left_le_midpoint I) hx.1, hx.2âŸ©

/-- If k â‰¤ m then the m-th interval is contained in the k-th interval. -/
lemma bisectionInterval_subset_of_le {f : â„ â†’ â„} (I : Interval) :
  âˆ€ {k m : â„•}, k â‰¤ m -> (IccOfInterval (bisectionInterval f m I)) âŠ† (IccOfInterval (bisectionInterval f k I))
:= by
  intros k m hk
  -- reduce to m = k + t
  obtain âŸ¨t, rfl, htâŸ© := (le_iff_exists_add.1 hk)
  induction t with
  | zero => simp
  | succ t ih =>
    -- m = k + (t+1) so bisectionInterval f (k + t + 1) I = bisectionInterval f (k + t) (bisectionStep f I)
    have hmk : bisectionInterval f (k + t + 1) I = bisectionInterval f (k + t) (bisectionStep f I) := rfl
    rw [â† add_assoc, hmk]
    -- apply IH (for t) to show: I_{k+t} (with starting interval bisectionStep f I) âŠ† I_k
    have step_sub : (IccOfInterval (bisectionStep f I)) âŠ† (IccOfInterval I) := bisectionStep_subset f I
    -- now apply IH with starting interval `bisectionStep f I`
    have ih' := ih (by
      -- show k â‰¤ k + t
      apply Nat.le_add_right)
    -- compose subset relations:
    induction k with
    | zero => 
    simp [zero_add] at *
    sorry
    | succ k ikh => sorry


/-- Distance between two midpoints is bounded by the diameter of the min-th interval. -/
lemma midpoint_dist_bound (f : â„ â†’ â„) (I : Interval) (m n : â„•) :
  |bisectionMidpoint f I m - bisectionMidpoint f I n| â‰¤ 
    intervalLength (bisectionInterval f (min m n) I) := by
  -- set k = min m n
  let k := min m n
  -- show both midpoints lie in the k-th closed interval
  have sub_m : bisectionMidpoint f I m âˆˆ IccOfInterval (bisectionInterval f k I) := by
    -- since k â‰¤ m, interval m âŠ† interval k, hence midpoint m (which is in interval m) is in interval k
    have hk : k â‰¤ m := Nat.min_le_left _ _
    have : (IccOfInterval (bisectionInterval f m I)) âŠ† (IccOfInterval (bisectionInterval f k I)) := bisectionInterval_subset_of_le I hk
    -- midpoint lies in its own interval
    have mid_in_m : bisectionMidpoint f I m âˆˆ IccOfInterval (bisectionInterval f m I) := by
      -- midpoint is between the endpoints of its interval
      let J := bisectionInterval f m I
      dsimp [bisectionMidpoint, midpoint]
      -- J.a â‰¤ midpoint â‰¤ J.b
      have h1: J.a â‰¤ (J.a + J.b) / 2 := by
        linarith [J.h]
      have h2: (J.a + J.b) / 2 â‰¤ J.b := by
        linarith
      exact âŸ¨ h1, h2 âŸ©
    exact this mid_in_m

  have sub_n : bisectionMidpoint f I n âˆˆ IccOfInterval (bisectionInterval f k I) := by
    sorry

  -- now both midpoints are in I_k = [a_k, b_k], so their distance is â‰¤ diameter(I_k)
  rcases (bisectionInterval f k I) with âŸ¨a_k, b_k, h_kâŸ©
  have left_bound : |bisectionMidpoint f I m - (a_k + b_k) / 2| â‰¤ (b_k - a_k) / 2 := by
    -- midpoint of any point in [a_k,b_k] to the center is at most half the length
    have p : bisectionMidpoint f I m âˆˆ Set.Icc a_k b_k := by
      rw [IccOfInterval] at sub_m
      sorry
    -- compute bound: |x - center| â‰¤ (b_k - a_k)/2
    -- equivalent to proving both inequalities by `linarith`
    have hx1 : bisectionMidpoint f I m â‰¤ (a_k + b_k) / 2 := by
      have := p.2
      sorry
    have hx2 : (a_k + b_k) / 2 â‰¤ bisectionMidpoint f I m := by
      have := p.1
      sorry
    -- combine into absolute value bound
    calc
      |bisectionMidpoint f I m - (a_k + b_k) / 2|
        = |(bisectionMidpoint f I m) - (a_k + b_k) / 2| := rfl
      _ â‰¤ (b_k - a_k) / 2 := by
        -- this reduces to simple linear arithmetic
        have : (a_k + b_k) / 2 - a_k = (b_k - a_k) / 2 := by ring
        have : b_k - (a_k + b_k) / 2 = (b_k - a_k) / 2 := by ring
        exact abs_le.2 âŸ¨by linarith, by linarithâŸ©

  have right_bound : |bisectionMidpoint f I n - (a_k + b_k) / 2| â‰¤ (b_k - a_k) / 2 := by
    -- same proof for n
    have p := sub_n
    have hx1 : bisectionMidpoint f I n â‰¤ (a_k + b_k) / 2 := by sorry
    have hx2 : (a_k + b_k) / 2 â‰¤ bisectionMidpoint f I n := by sorry
    exact abs_le.2 âŸ¨by linarith, by linarithâŸ©

  -- triangle inequality: |x - y| â‰¤ |x - c| + |y - c|
  sorry

/--
The bisection midpoint sequence converges to the unique point in the nested
interval intersection, which is a root of `f`.
-/
theorem bisection_converges
    {Iâ‚€ : Interval} (f : â„ â†’ â„)
    (hcont : Continuous f)
    (hroot : f Iâ‚€.a * f Iâ‚€.b â‰¤ 0) :
    âˆƒ x,
      Tendsto (fun n => bisectionMidpoint f Iâ‚€ n) atTop (ð“ x)
      âˆ§ f x = 0 := by
  -- The key idea: nested intervals with shrinking diameter
  -- By Cantor's nested interval theorem, the intersection is a single point
  
  -- First, show the sequence is Cauchy
  have cauchy : CauchySeq (fun n => bisectionMidpoint f Iâ‚€ n) := by
    have {a:= aâ‚€, b:= bâ‚€, h:= hâ‚€} := Iâ‚€
    apply Metric.cauchySeq_iff'.mpr
    intro Îµ hÎµ
    -- Use diam_tendsto_zero to find N where diam < Îµ
    have := diam_tendsto_zero f Iâ‚€
    rw [Metric.tendsto_atTop] at this
    obtain âŸ¨N, hNâŸ© := this Îµ hÎµ
    use N
    intro m hm
    -- Show |xâ‚˜ - xâ‚™| â‰¤ diam of interval, which is < Îµ
    sorry
  
  -- Since â„ is complete, Cauchy sequence converges
  obtain âŸ¨x, hxâŸ© := cauchySeq_tendsto_of_complete cauchy
  use x
  constructor
  Â· exact hx
  Â· -- Show f x = 0 by continuity
    -- Each interval contains a sign change
    -- The limit point must be a root
    sorry -- Would need to show:
    -- 1. f preserves sign change at endpoints of each interval
    -- 2. Endpoints converge to x
    -- 3. Therefore f(x) must be zero by continuity

end Convergence


/-! ## Quantitative Bounds -/

/-- Helper: nested intervals preserve containment -/
lemma nested_intervals_preserve_containment (f : â„ â†’ â„) (I : Interval) (n : â„•) :
    âˆ€ x, x âˆˆ Set.Icc I.a I.b â†’ 
    have {a:= aâ‚™, b:= bâ‚™, h:= hâ‚™} := bisectionInterval f n I
    x âˆˆ Set.Icc aâ‚™ bâ‚™ := by
  sorry -- Requires proving bisection maintains sign change property

/-- After `n` steps, the bisection approximation differs from any root
in the initial interval by at most `(bâ‚€ - aâ‚€) / 2^(n+1)`. -/
theorem bisection_error_bound
    (f : â„ â†’ â„) (I : Interval) (n : â„•) :
    let xâ‚™ := bisectionMidpoint f I n
    have {a:= aâ‚€, b:= bâ‚€, h:= hâ‚€} := I
    âˆ€ x âˆˆ Set.Icc aâ‚€ bâ‚€,
      |xâ‚™ - x| â‰¤ intervalLength I / (2^(n+1)) := by
  intro x hx  
  -- Let (aâ‚™, bâ‚™) be the n-th interval
  have {a:= aâ‚™, b:= bâ‚™, h:= hâ‚™} := bisectionInterval f n I
  set xâ‚™ := (aâ‚™ + bâ‚™) / 2
  
  -- Key fact: x must be in [aâ‚™, bâ‚™] (nested intervals preserve the root)
  have x_in_interval : x âˆˆ Set.Icc aâ‚™ bâ‚™ := by
    sorry
  
  -- Therefore |xâ‚™ - x| â‰¤ (bâ‚™ - aâ‚™) / 2
  have bound_by_half_interval : |xâ‚™ - x| â‰¤ (bâ‚™ - aâ‚™) / 2 := by
    have hx_le_b : x â‰¤ bâ‚™ := x_in_interval.2
    have ha_le_x : aâ‚™ â‰¤ x := x_in_interval.1
    rw [abs_sub_le_iff]
    constructor
    Â· -- xâ‚™ - x â‰¤ (bâ‚™ - aâ‚™) / 2
      have : xâ‚™ = (aâ‚™ + bâ‚™) / 2 := rfl
      linarith
    Â· -- -(bâ‚™ - aâ‚™) / 2 â‰¤ xâ‚™ - x
      have : xâ‚™ = (aâ‚™ + bâ‚™) / 2 := rfl
      linarith
  
  -- Use intervalLength_bisectionInterval: bâ‚™ - aâ‚™ = (bâ‚€ - aâ‚€) / 2^n
  sorry

end Numerical
