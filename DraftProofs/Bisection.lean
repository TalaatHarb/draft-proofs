/-
# Numerical Analysis: The Bisection Method

This file develops the classical **bisection root-finding method** for continuous
real functions. It contains:

* A definition of a single bisection step
* The recursive sequence of bisection intervals
* Midpoints of these intervals
* A proof that interval lengths shrink to zero
* Convergence of the midpoint sequence to a root
* A quantitative error bound after `n` iterations

This is structured according to mathlib conventions and is intended as a starting
point for a full formalization.
-/

import Mathlib.Topology.Basic
import Mathlib.Data.Real.Basic
import Mathlib.Analysis.Calculus.MeanValue
import Mathlib.Analysis.SpecialFunctions.Pow.Real

open scoped Topology
open Filter

noncomputable section

namespace Numerical

structure Interval where
  a : â„
  b : â„
  h : a â‰¤ b

@[simp] def midpoint (I : Interval) : â„ := (I.a + I.b) / 2

def IccOfInterval (I : Interval) : Set â„ := Set.Icc I.a I.b

/-! ## Bisection Step -/

/-- A single bisection step: given a function `f` and an interval `[a, b]`
with a sign change, return the next subinterval containing the root. -/
def bisectionStep (f : â„ â†’ â„) (I : Interval) : Interval :=
  if h : f I.a * f (midpoint I) â‰¤ 0 then
    { a := I.a, b := (midpoint I), h : I.a â‰¤ (midpoint I) := by simp; linarith[I.h] }
  else
    { a := (midpoint I), b := I.b, h : (midpoint I) â‰¤ I.b := by simp; linarith[I.h] }

/-- Length of a real interval. -/
@[simp] def intervalLength (I : Interval) : â„ := I.b - I.a

/-! ## Recursive interval sequence -/

/-- The `n`-th interval generated by the bisection method. -/
def bisectionInterval (f : â„ â†’ â„) : â„• â†’ Interval â†’ Interval
  | 0,   I  => I
  | n+1, I  =>
      let next := bisectionStep f I
      bisectionInterval f n next

/-- The midpoint of the `n`-th bisection interval. -/
def bisectionMidpoint (f : â„ â†’ â„) (I : Interval) (n : â„•) : â„ :=
  let In := bisectionInterval f n I
  (In.a + In.b) / 2


/-! ## Interval-shrinking lemmas -/

section IntervalShrink

lemma interval_left_le_midpoint (I: Interval) : I.a â‰¤ midpoint I := by
  simp
  linarith [I.h]

lemma interval_midpoint_le_right (I: Interval) : midpoint I â‰¤ I.b := by
  simp
  linarith [I.h]

/-- The interval length after one bisection step is half the original. -/
lemma intervalLength_bisectionStep (f : â„ â†’ â„) (I: Interval):
    intervalLength (bisectionStep f I) = (I.b - I.a) / 2 := by
  dsimp [bisectionStep, intervalLength]
  by_cases h : f I.a * f (midpoint I) â‰¤ 0
  all_goals
  Â· split
    all_goals
    ring_nf


lemma intervalLength_bisectionInterval (f : â„ â†’ â„) (I : Interval) :
  âˆ€ n : â„•, intervalLength (bisectionInterval f n I) = intervalLength I / 2^n
:= by
  intro n
  induction n generalizing I with
  | zero => simp [bisectionInterval, intervalLength, pow_zero]
  | succ n ih =>
    -- let J be the interval after one bisection step
    let J := bisectionStep f I
    -- Apply the inductive hypothesis to J (not I!)
    have ihJ : intervalLength (bisectionInterval f n J) = intervalLength J / 2^n := by exact ih J
    simp only [bisectionInterval]
    rw [ihJ]
    -- Now we need: intervalLength J / 2^n = intervalLength (a, b) / 2^(n+1)
    rw [intervalLength_bisectionStep]
    -- We have: ((b - a) / 2) / 2^n = (b - a) / 2^(n+1)
    simp [intervalLength, pow_succ]
    ring_nf



/-- The interval diameters tend to zero as `n â†’ âˆž`. -/
lemma diam_tendsto_zero (f : â„ â†’ â„) (I : Interval) :
  Tendsto (fun n => intervalLength (bisectionInterval f n I))
          atTop (ð“ 0) := by
  simp_rw [intervalLength_bisectionInterval]
  have hs : (fun n => intervalLength I / 2 ^ n) = 
         (fun n => intervalLength I * (1 / 2) ^ n) := by
    ext n
    simp
    ring_nf
  rw [hs]
  have hpow : Tendsto (fun n => (1 / 2 : â„) ^ n) atTop (ð“ 0) := by
    apply tendsto_pow_atTop_nhds_zero_of_lt_one
    Â· norm_num
    Â· norm_num
  convert Tendsto.const_mul (intervalLength I) hpow using 1
  simp

end IntervalShrink


/-! ## Convergence of the bisection method -/

section Convergence

/-- Helper lemma: midpoints of nested intervals stay within bounds -/
lemma midpoint_in_interval (f : â„ â†’ â„) (I : Interval) (n : â„•) :
    have {a:= aâ‚€, b:= bâ‚€, h:= _} := I
    have {a:= aâ‚™, b:= bâ‚™, h:= _} := bisectionInterval f n I
    aâ‚€ â‰¤ aâ‚™ âˆ§ aâ‚™ â‰¤ bâ‚™ âˆ§ bâ‚™ â‰¤ bâ‚€ := by
    constructor
    . induction n generalizing I with
      | zero => simp [bisectionInterval]
      | succ n ih => 
      simp [bisectionInterval]
      . have ihJ := ih (bisectionStep f I)
        have hi : I.a â‰¤ (bisectionStep f I).a := by      
          -- bisection always shrinks toward the middle:
          -- The new 'a' is either I.a or midpoint(I), both â‰¥ I.a
          rw [bisectionStep]
          by_cases hfp : f I.a * f (midpoint I) â‰¤ 0
          Â· -- left interval: new a = old a
            split
            . simp
            . contradiction
          Â· -- right interval: new a = midpoint â‰¥ a
            split
            . contradiction
            . simp; linarith [I.h]
        apply le_trans hi
        exact ihJ
    . constructor
      . exact (bisectionInterval f n I).h
      . induction n generalizing I with
      | zero => simp [bisectionInterval]
      | succ n ih => 
      simp [bisectionInterval]
      . have ihJ := ih (bisectionStep f I)
        have hi :  (bisectionStep f I).b â‰¤ I.b := by      
          -- bisection always shrinks toward the middle:
          -- The new 'a' is either I.a or midpoint(I), both â‰¥ I.a
          rw [bisectionStep]
          by_cases hfp : f I.a * f (midpoint I) â‰¤ 0
          Â· -- left interval: new a = old a
            split
            . simp; linarith [I.h]
            . contradiction
          Â· -- right interval: new a = midpoint â‰¥ a
            split
            . contradiction
            . simp
        apply le_trans ihJ
        exact hi

/-- The interval produced by one bisection step is contained in the original interval. -/
lemma bisectionStep_subset (f : â„ â†’ â„) (I : Interval) :
  IccOfInterval (bisectionStep f I) âŠ† IccOfInterval I := by
  -- expand definitions and do a case split on the `if` in `bisectionStep`
  dsimp [bisectionStep, IccOfInterval, midpoint]
  by_cases h : f I.a * f (midpoint I) â‰¤ 0
  Â· -- left branch: interval is [I.a, m]
    split
    . -- show {x | I.a â‰¤ x âˆ§ x â‰¤ m} âŠ† {x | I.a â‰¤ x âˆ§ x â‰¤ I.b}
      intro x hx
      exact âŸ¨hx.1, le_trans hx.2 (interval_midpoint_le_right I)âŸ©
    . -- show {x | I.a â‰¤ x âˆ§ x â‰¤ m} âŠ† {x | I.a â‰¤ x âˆ§ x â‰¤ I.b}
      intro x hx
      exact âŸ¨le_trans (interval_left_le_midpoint I) hx.1, hx.2âŸ©
  Â· -- right branch: interval is [m, I.b]
    split
    . -- show {x | I.a â‰¤ x âˆ§ x â‰¤ m} âŠ† {x | I.a â‰¤ x âˆ§ x â‰¤ I.b}
      intro x hx
      exact âŸ¨hx.1, le_trans hx.2 (interval_midpoint_le_right I)âŸ©
    . -- show {x | I.a â‰¤ x âˆ§ x â‰¤ m} âŠ† {x | I.a â‰¤ x âˆ§ x â‰¤ I.b}
      intro x hx
      exact âŸ¨le_trans (interval_left_le_midpoint I) hx.1, hx.2âŸ©

/-- One-step monotonicity: the (n+1)-th interval is contained in the n-th interval,
    for any starting interval `J`. This is proved by induction on `n`, generalized
    over the starting interval. -/
lemma bisectionInterval_one_step_subset (f : â„ â†’ â„) :
  âˆ€ n (J : Interval), (IccOfInterval (bisectionInterval f (n + 1) J)) âŠ† (IccOfInterval (bisectionInterval f n J)) := by
  intro n J
  induction n generalizing J with
  | zero =>
    -- bisectionInterval f 1 J = bisectionStep f J and bisectionInterval f 0 J = J
    simp [bisectionInterval]
    exact bisectionStep_subset f J
  | succ n ih =>
    -- bisectionInterval f (n+2) J = bisectionInterval f (n+1) (bisectionStep f J)
    simp [bisectionInterval]
    -- apply IH to the starting interval `bisectionStep f J`
    exact ih (bisectionStep f J)

lemma bisectionInterval_subset_of_le {f : â„ â†’ â„} (I : Interval) :
  âˆ€ {k m : â„•}, k â‰¤ m -> (IccOfInterval (bisectionInterval f m I)) âŠ† (IccOfInterval (bisectionInterval f k I)) := by
  intros k m hk
  obtain âŸ¨t, rflâŸ© := (le_iff_exists_add.1 hk)  -- m = k + t
  induction t with
  | zero => simp
  | succ t ih =>
    -- I_{k + t + 1} âŠ† I_{k + t} by one-step monotonicity, then use IH
    have step_sub := bisectionInterval_one_step_subset f (k + t) I
    exact (step_sub.trans (ih (Nat.le_add_right k t)) : _)

lemma midpoint_dist_bound (f : â„ â†’ â„) (I : Interval) (m n : â„•) :
  |bisectionMidpoint f I m - bisectionMidpoint f I n| â‰¤
    intervalLength (bisectionInterval f (min m n) I) := by
  -- Set k = min m n
  let k := min m n
  have hk_m : k â‰¤ m := Nat.min_le_left _ _
  have hk_n : k â‰¤ n := Nat.min_le_right _ _

  -- Midpoint m lies in interval m
  have mid_m_in_m :
      bisectionMidpoint f I m âˆˆ IccOfInterval (bisectionInterval f m I) := by
    let J := bisectionInterval f m I
    dsimp [bisectionMidpoint, midpoint]
    have h1 : J.a â‰¤ (J.a + J.b)/2 := by linarith [J.h]
    have h2 : (J.a + J.b)/2 â‰¤ J.b := by linarith
    exact âŸ¨h1, h2âŸ©

  -- Midpoint n lies in interval n
  have mid_n_in_n :
      bisectionMidpoint f I n âˆˆ IccOfInterval (bisectionInterval f n I) := by
    let J := bisectionInterval f n I
    dsimp [bisectionMidpoint, midpoint]
    have h1 : J.a â‰¤ (J.a + J.b)/2 := by linarith [J.h]
    have h2 : (J.a + J.b)/2 â‰¤ J.b := by linarith
    exact âŸ¨h1, h2âŸ©

  -- interval m âŠ† interval k because k â‰¤ m
  have sub_mk :
      IccOfInterval (bisectionInterval f m I) âŠ†
      IccOfInterval (bisectionInterval f k I) :=
    bisectionInterval_subset_of_le I hk_m

  -- interval n âŠ† interval k because k â‰¤ n
  have sub_nk :
      IccOfInterval (bisectionInterval f n I) âŠ†
      IccOfInterval (bisectionInterval f k I) :=
    bisectionInterval_subset_of_le I hk_n

  -- Therefore both midpoints lie in interval k
  have mid_m_in_k : bisectionMidpoint f I m âˆˆ IccOfInterval (bisectionInterval f k I) :=
    sub_mk mid_m_in_m
  have mid_n_in_k : bisectionMidpoint f I n âˆˆ IccOfInterval (bisectionInterval f k I) :=
    sub_nk mid_n_in_n

  -- Unpack interval k
  -- Let Jk be the k-th interval
  set Jk := bisectionInterval f k I with hJk

  -- rewrite the midpoint memberships
  simp [hJk, IccOfInterval] at mid_m_in_k mid_n_in_k

  apply abs_le.2
  constructor
  all_goals
  . simp [Jk]
    linarith


/--
The bisection midpoint sequence converges to the unique point in the nested
interval intersection, which is a root of `f`.
-/
theorem bisection_converges
    {Iâ‚€ : Interval} (f : â„ â†’ â„)
    (hcont : Continuous f)
    (hroot : f Iâ‚€.a * f Iâ‚€.b â‰¤ 0) :
    âˆƒ x,
      Tendsto (fun n => bisectionMidpoint f Iâ‚€ n) atTop (ð“ x)
      âˆ§ f x = 0 := by
  -- The key idea: nested intervals with shrinking diameter
  -- By Cantor's nested interval theorem, the intersection is a single point
  
  -- First, show the sequence is Cauchy
  have cauchy : CauchySeq (fun n => bisectionMidpoint f Iâ‚€ n) := by
    have {a:= aâ‚€, b:= bâ‚€, h:= hâ‚€} := Iâ‚€
    apply Metric.cauchySeq_iff'.mpr
    intro Îµ hÎµ
    -- Use diam_tendsto_zero to find N where diam < Îµ
    have := diam_tendsto_zero f Iâ‚€
    rw [Metric.tendsto_atTop] at this
    obtain âŸ¨N, hNâŸ© := this Îµ hÎµ
    use N
    intro m hm
    -- Show |xâ‚˜ - xâ‚™| â‰¤ diam of interval, which is < Îµ
    sorry
  
  -- Since â„ is complete, Cauchy sequence converges
  obtain âŸ¨x, hxâŸ© := cauchySeq_tendsto_of_complete cauchy
  use x
  constructor
  Â· exact hx
  Â· -- Show f x = 0 by continuity
    -- Each interval contains a sign change
    -- The limit point must be a root
    sorry -- Would need to show:
    -- 1. f preserves sign change at endpoints of each interval
    -- 2. Endpoints converge to x
    -- 3. Therefore f(x) must be zero by continuity

end Convergence


/-! ## Quantitative Bounds -/

/-- Helper: nested intervals preserve containment -/
lemma nested_intervals_preserve_containment (f : â„ â†’ â„) (I : Interval) (n : â„•) :
    âˆ€ x, x âˆˆ Set.Icc I.a I.b â†’ 
    have {a:= aâ‚™, b:= bâ‚™, h:= hâ‚™} := bisectionInterval f n I
    x âˆˆ Set.Icc aâ‚™ bâ‚™ := by
  sorry -- Requires proving bisection maintains sign change property

/-- After `n` steps, the bisection approximation differs from any root
in the initial interval by at most `(bâ‚€ - aâ‚€) / 2^(n+1)`. -/
theorem bisection_error_bound
    (f : â„ â†’ â„) (I : Interval) (n : â„•) :
    let xâ‚™ := bisectionMidpoint f I n
    have {a:= aâ‚€, b:= bâ‚€, h:= hâ‚€} := I
    âˆ€ x âˆˆ Set.Icc aâ‚€ bâ‚€,
      |xâ‚™ - x| â‰¤ intervalLength I / (2^(n+1)) := by
  intro x hx  
  -- Let (aâ‚™, bâ‚™) be the n-th interval
  have {a:= aâ‚™, b:= bâ‚™, h:= hâ‚™} := bisectionInterval f n I
  set xâ‚™ := (aâ‚™ + bâ‚™) / 2
  
  -- Key fact: x must be in [aâ‚™, bâ‚™] (nested intervals preserve the root)
  have x_in_interval : x âˆˆ Set.Icc aâ‚™ bâ‚™ := by
    sorry
  
  -- Therefore |xâ‚™ - x| â‰¤ (bâ‚™ - aâ‚™) / 2
  have bound_by_half_interval : |xâ‚™ - x| â‰¤ (bâ‚™ - aâ‚™) / 2 := by
    have hx_le_b : x â‰¤ bâ‚™ := x_in_interval.2
    have ha_le_x : aâ‚™ â‰¤ x := x_in_interval.1
    rw [abs_sub_le_iff]
    constructor
    Â· -- xâ‚™ - x â‰¤ (bâ‚™ - aâ‚™) / 2
      have : xâ‚™ = (aâ‚™ + bâ‚™) / 2 := rfl
      linarith
    Â· -- -(bâ‚™ - aâ‚™) / 2 â‰¤ xâ‚™ - x
      have : xâ‚™ = (aâ‚™ + bâ‚™) / 2 := rfl
      linarith
  
  -- Use intervalLength_bisectionInterval: bâ‚™ - aâ‚™ = (bâ‚€ - aâ‚€) / 2^n
  sorry

end Numerical