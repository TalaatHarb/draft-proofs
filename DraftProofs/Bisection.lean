/-
# Numerical Analysis: The Bisection Method

This file formalizes the classical bisection method for continuous real functions.

Main definitions:
* `Interval` ‚Äî a closed interval `[a, b] : ‚Ñù` with `a ‚â§ b`.
* `bisectionStep f I` ‚Äî one bisection step, returning an `Interval` of half length.
* `bisectionInterval f n I` ‚Äî `n`-th interval obtained by iterating `bisectionStep`.
* `bisectionMidpoint f I n` ‚Äî midpoint of `bisectionInterval f n I`.

Main theorems:
* `diam_tendsto_zero`: the interval lengths converge to `0`.
* `bisection_converges`: the midpoint sequence is Cauchy and converges to a root.
* `bisection_error_bound`: quantitative error bound after `n` steps.

## TODO

* Add a result showing uniqueness of the root under `f` monotone / continuous with sign-change.
* Add examples / tests.
-/

/- ### Implementation notes

We define a tiny `Interval` structure for convenience; all results could be restated
using `Set.Icc`, but `Interval` clarifies `a`, `b` and the invariant `a ‚â§ b`.

All proofs are constructive and avoid classical choice. The main convergence theorem
`bisection_converges` assumes continuity of `f` and existence of a sign change
`f I.a * f I.b ‚â§ 0`.
-/

import Mathlib.Topology.Basic
import Mathlib.Data.Real.Basic
import Mathlib.Analysis.Calculus.MeanValue

open scoped Topology
open Filter

noncomputable section

namespace Numerical

structure Interval where
  a : ‚Ñù
  b : ‚Ñù
  h : a ‚â§ b

/-- Midpoint of a real interval. -/
@[simp] def midpoint (I : Interval) : ‚Ñù := (I.a + I.b) / 2

/-- Length of a real interval. -/
@[simp] def intervalLength (I : Interval) : ‚Ñù := I.b - I.a

/-- Construct `Icc` out of a real interval. -/
def IccOfInterval (I : Interval) : Set ‚Ñù := Set.Icc I.a I.b

/-! ## Bisection Step -/

/-- A single bisection step: given a function `f` and an interval `[a, b]`
with a sign change, return the next subinterval containing the root. -/
def bisectionStep (f : ‚Ñù ‚Üí ‚Ñù) (I : Interval) : Interval :=
  if h : f I.a * f (midpoint I) ‚â§ 0 then
    { a := I.a, b := (midpoint I), h : I.a ‚â§ (midpoint I) := by simp only [midpoint]; linarith[I.h] }
  else
    { a := (midpoint I), b := I.b, h : (midpoint I) ‚â§ I.b := by simp only [midpoint]; linarith[I.h] }


/-! ## Recursive interval sequence -/

/-- The `n`-th interval generated by the bisection method. -/
def bisectionInterval (f : ‚Ñù ‚Üí ‚Ñù) : ‚Ñï ‚Üí Interval ‚Üí Interval
  | 0,   I  => I
  | n+1, I  => bisectionInterval f n (bisectionStep f I)

/-- The midpoint of the `n`-th bisection interval. -/
def bisectionMidpoint (f : ‚Ñù ‚Üí ‚Ñù) (I : Interval) (n : ‚Ñï) : ‚Ñù :=
  midpoint (bisectionInterval f n I)

/-! ## Interval-shrinking lemmas -/

section IntervalShrink

/-- The interval start less than or equal the midpoint -/
lemma interval_left_le_midpoint (I: Interval) : I.a ‚â§ midpoint I := by
  simp only [midpoint]
  linarith [I.h]

/-- The interval midpoint less than or equal the interval end -/
lemma interval_midpoint_le_right (I: Interval) : midpoint I ‚â§ I.b := by
  simp only [midpoint]
  linarith [I.h]

/-- The interval length after one bisection step is half the original. -/
lemma intervalLength_bisectionStep (f : ‚Ñù ‚Üí ‚Ñù) (I: Interval):
    intervalLength (bisectionStep f I) = (I.b - I.a) / 2 := by
  dsimp only [bisectionStep, midpoint, intervalLength]
  by_cases h : f I.a * f (midpoint I) ‚â§ 0
  all_goals (split; all_goals (ring_nf))


/-- The interval length after the `n-th` bisection step is `1/2^n` the original interval length. -/
lemma intervalLength_bisectionInterval (f : ‚Ñù ‚Üí ‚Ñù) (I : Interval) :
  ‚àÄ n : ‚Ñï, intervalLength (bisectionInterval f n I) = intervalLength I / 2^n
:= by
  intro n
  induction n generalizing I with
  | zero => simp only [intervalLength, bisectionInterval, pow_zero, div_one]
  | succ n ih =>
    simp only [bisectionInterval]
    let J := bisectionStep f I
    have ihJ : intervalLength (bisectionInterval f n J) = intervalLength J / 2^n := by exact ih J
    rw [ihJ, intervalLength_bisectionStep, pow_succ, intervalLength]
    exact Eq.symm (div_mul_eq_div_div_swap (I.b - I.a) (2 ^ n) 2)

/-- The interval diameters tend to zero as `n ‚Üí ‚àû`. -/
lemma diam_tendsto_zero (f : ‚Ñù ‚Üí ‚Ñù) (I : Interval) :
  Tendsto (fun n => intervalLength (bisectionInterval f n I))
          atTop (ùìù 0) := by
  simp_rw [intervalLength_bisectionInterval]
  have hs : (fun n => intervalLength I / 2 ^ n) = 
         (fun n => intervalLength I * (1 / 2) ^ n) := by
    ext n
    simp [intervalLength]
    exact rfl
  rw [hs]
  have hpow : Tendsto (fun n => (1 / 2 : ‚Ñù) ^ n) atTop (ùìù 0) := by
    apply tendsto_pow_atTop_nhds_zero_of_lt_one _ _
    all_goals (norm_num)
  convert Tendsto.const_mul (intervalLength I) hpow using 1
  rw [mul_zero]

end IntervalShrink


/-! ## Convergence of the bisection method -/

section Convergence

/-- Helper lemma: nested intervals start and ed stay within bounds of original interval -/
lemma nested_interval_in_interval (f : ‚Ñù ‚Üí ‚Ñù) (I : Interval) (n : ‚Ñï) :
    have {a:= a‚ÇÄ, b:= b‚ÇÄ, h:= _} := I
    have {a:= a‚Çô, b:= b‚Çô, h:= _} := bisectionInterval f n I
    a‚ÇÄ ‚â§ a‚Çô ‚àß a‚Çô ‚â§ b‚Çô ‚àß b‚Çô ‚â§ b‚ÇÄ := by
    constructor
    . induction n generalizing I with
      | zero => simp [bisectionInterval]
      | succ n ih => 
      simp only [bisectionInterval]
      . have ihJ := ih (bisectionStep f I)
        have hi : I.a ‚â§ (bisectionStep f I).a := by      
          rw [bisectionStep]
          by_cases hfp : f I.a * f (midpoint I) ‚â§ 0
          ¬∑ -- left interval: new a = old a
            split
            . simp
            . contradiction
          ¬∑ -- right interval: new a = midpoint ‚â• a
            split
            . contradiction
            . simp only [midpoint]; linarith [I.h]
        apply le_trans hi
        exact ihJ
    . constructor
      . exact (bisectionInterval f n I).h
      . induction n generalizing I with
      | zero => simp [bisectionInterval]
      | succ n ih => 
      simp only [bisectionInterval]
      . have ihJ := ih (bisectionStep f I)
        have hi :  (bisectionStep f I).b ‚â§ I.b := by      
          -- bisection always shrinks toward the middle:
          -- The new 'a' is either I.a or midpoint(I), both ‚â• I.a
          rw [bisectionStep]
          by_cases hfp : f I.a * f (midpoint I) ‚â§ 0
          ¬∑ -- left interval: new a = old a
            split
            . simp only [midpoint]; linarith [I.h]
            . contradiction
          ¬∑ -- right interval: new a = midpoint ‚â• a
            split
            . contradiction
            . simp
        apply le_trans ihJ
        exact hi

/-- The interval produced by one bisection step is contained in the original interval. -/
lemma bisectionStep_subset (f : ‚Ñù ‚Üí ‚Ñù) (I : Interval) :
  IccOfInterval (bisectionStep f I) ‚äÜ IccOfInterval I := by
  dsimp only [bisectionStep, midpoint, IccOfInterval]
  by_cases h : f I.a * f (midpoint I) ‚â§ 0
  ¬∑ -- left branch: interval is [I.a, m]
    split
    . intro x hx
      exact ‚ü®hx.1, le_trans hx.2 (interval_midpoint_le_right I)‚ü©
    . intro x hx
      exact ‚ü®le_trans (interval_left_le_midpoint I) hx.1, hx.2‚ü©
  ¬∑ -- right branch: interval is [m, I.b]
    split
    . intro x hx
      exact ‚ü®hx.1, le_trans hx.2 (interval_midpoint_le_right I)‚ü©
    . intro x hx
      exact ‚ü®le_trans (interval_left_le_midpoint I) hx.1, hx.2‚ü©

/-- One-step monotonicity: the (n+1)-th interval is contained in the n-th interval,
    for any starting interval `I`. This is proved by induction on `n`, generalized
    over the starting interval. -/
lemma bisectionInterval_one_step_subset (f : ‚Ñù ‚Üí ‚Ñù) :
  ‚àÄ (n: ‚Ñï) (I : Interval), (IccOfInterval (bisectionInterval f (n + 1) I)) ‚äÜ (IccOfInterval (bisectionInterval f n I)) := by
  intro n I
  induction n generalizing I with
  | zero =>
    simp only [bisectionInterval]
    exact bisectionStep_subset f I
  | succ n ih =>
    simp only [bisectionInterval]
    exact ih (bisectionStep f I)

/-- Multi-step monotonicity: the `m-th` interval is contained in the `k-th` interval,
    for any starting interval `I` -/
lemma bisectionInterval_subset_of_le {f : ‚Ñù ‚Üí ‚Ñù} (I : Interval) :
  ‚àÄ {k m : ‚Ñï}, k ‚â§ m -> (IccOfInterval (bisectionInterval f m I)) ‚äÜ (IccOfInterval (bisectionInterval f k I)) := by
  intros k m hk
  obtain ‚ü®t, rfl‚ü© := (le_iff_exists_add.1 hk)  -- m = k + t
  induction t with
  | zero => simp
  | succ t ih =>
    have step_sub := bisectionInterval_one_step_subset f (k + t) I
    exact (step_sub.trans (ih (Nat.le_add_right k t)) : _)

/-- Bounds on the distance between midpoints of different steps -/
lemma midpoint_dist_bound (f : ‚Ñù ‚Üí ‚Ñù) (I : Interval) (m n : ‚Ñï) :
  |bisectionMidpoint f I m - bisectionMidpoint f I n| ‚â§
    intervalLength (bisectionInterval f (min m n) I) := by
  -- Set k = min m n
  let k := min m n
  have hk_m : k ‚â§ m := Nat.min_le_left _ _
  have hk_n : k ‚â§ n := Nat.min_le_right _ _

  -- Midpoint m lies in interval m
  have mid_m_in_m :
      bisectionMidpoint f I m ‚àà IccOfInterval (bisectionInterval f m I) := by
    let J := bisectionInterval f m I
    dsimp only [bisectionMidpoint]
    have h1 : J.a ‚â§ (J.a + J.b)/2 := by linarith [J.h]
    have h2 : (J.a + J.b)/2 ‚â§ J.b := by linarith
    exact ‚ü®h1, h2‚ü©

  -- Midpoint n lies in interval n
  have mid_n_in_n :
      bisectionMidpoint f I n ‚àà IccOfInterval (bisectionInterval f n I) := by
    let J := bisectionInterval f n I
    dsimp only [bisectionMidpoint]
    have h1 : J.a ‚â§ (J.a + J.b)/2 := by linarith [J.h]
    have h2 : (J.a + J.b)/2 ‚â§ J.b := by linarith
    exact ‚ü®h1, h2‚ü©

  -- interval m ‚äÜ interval k because k ‚â§ m
  have sub_mk :
      IccOfInterval (bisectionInterval f m I) ‚äÜ
      IccOfInterval (bisectionInterval f k I) :=
    bisectionInterval_subset_of_le I hk_m

  -- interval n ‚äÜ interval k because k ‚â§ n
  have sub_nk :
      IccOfInterval (bisectionInterval f n I) ‚äÜ
      IccOfInterval (bisectionInterval f k I) :=
    bisectionInterval_subset_of_le I hk_n

  -- Therefore both midpoints lie in interval k
  have mid_m_in_k : bisectionMidpoint f I m ‚àà IccOfInterval (bisectionInterval f k I) :=
    sub_mk mid_m_in_m
  have mid_n_in_k : bisectionMidpoint f I n ‚àà IccOfInterval (bisectionInterval f k I) :=
    sub_nk mid_n_in_n

  -- Unpack interval k
  -- rewrite the midpoint memberships
  simp [IccOfInterval] at mid_m_in_k mid_n_in_k
  simp only [intervalLength]
  apply abs_le.2 _
  constructor
  all_goals (linarith)

/-- Single bisection step preserves the sign-change property:
    if f a * f b ‚â§ 0 then the new endpoints also have product ‚â§ 0. -/
lemma bisectionStep_preserve_sign_change {f : ‚Ñù ‚Üí ‚Ñù} (I : Interval)
  (h : f I.a * f I.b ‚â§ 0) : f (bisectionStep f I).a * f (bisectionStep f I).b ‚â§ 0 := by
  dsimp only [bisectionStep, midpoint]
  by_cases hmid : f I.a * f ((I.a + I.b) / 2) ‚â§ 0
  ¬∑ -- left branch: (a, midpoint)
    simp [hmid]
  ¬∑ -- right branch: (midpoint, b)
    simp only [hmid]
    have hpos : 0 < f I.a * f ((I.a + I.b) / 2) := lt_of_not_ge hmid
    by_cases fa0 : f I.a = 0
    ¬∑ rw [fa0, zero_mul] at hpos
      norm_num at hpos
    ¬∑ cases lt_or_gt_of_ne fa0 with
      -- f a > 0
      | inr =>
        have hfb : f I.b ‚â§ 0 := by
          apply nonpos_of_mul_nonpos_right h
          assumption
        have hfab : 0 ‚â§ f ((I.a + I.b) / 2) := by
          rw [mul_comm] at hpos
          apply le_of_lt
          apply (pos_of_mul_pos_left hpos)
          linarith
        exact mul_nonpos_of_nonneg_of_nonpos hfab hfb
      -- f a < 0
      | inl =>
        have hfb : 0 ‚â§ f I.b := by
          apply nonneg_of_mul_nonpos_right h
          assumption
        have hfab : f ((I.a + I.b) / 2) ‚â§ 0 := by
          apply le_of_lt
          apply (neg_of_mul_pos_right hpos)
          linarith
        exact mul_nonpos_of_nonpos_of_nonneg hfab hfb

/-- Multiple bisection step preserves the sign-change property:
    if f a * f b ‚â§ 0 then the new endpoints also have product ‚â§ 0. -/
lemma bisectionStep_preserve_sign_change_inductive
    (f : ‚Ñù ‚Üí ‚Ñù) (I‚ÇÄ : Interval)
    (hroot : f I‚ÇÄ.a * f I‚ÇÄ.b ‚â§ 0) :
    ‚àÄ n,
      f (bisectionInterval f n I‚ÇÄ).a *
      f (bisectionInterval f n I‚ÇÄ).b ‚â§ 0 := by
  intro n
  induction n with
  | zero => simpa only [bisectionInterval] using hroot
  | succ n ih =>
    simp only [bisectionInterval]
    have h:= bisectionStep_preserve_sign_change (bisectionInterval f n I‚ÇÄ) ih
    have hn : bisectionStep f (bisectionInterval f n I‚ÇÄ) = bisectionInterval f n (bisectionStep f I‚ÇÄ) := by
      induction n with
      | zero => simp only [bisectionInterval]
      | succ n ih =>
        simp only [bisectionInterval]
        
        have hi : ‚àÄ(I: Interval) (k: ‚Ñï), (bisectionStep f (bisectionInterval f k I)) = (bisectionInterval f (k + 1) I) := by
          intro I k
          simp only [bisectionInterval]
          induction k generalizing I with
          | zero => simp only [bisectionInterval]
          | succ k ihk => exact ihk (bisectionStep f I)
        
        exact hi (bisectionStep f I‚ÇÄ) n
    
    rw [hn] at h
    exact h

/-- Repeated bisection is cauchy -/
lemma bisection_cauchy (f : ‚Ñù ‚Üí ‚Ñù) (I‚ÇÄ : Interval) :
  CauchySeq (fun n => bisectionMidpoint f I‚ÇÄ n) := by
  -- Use the metric Cauchy characterization
  apply Metric.cauchySeq_iff'.mpr
  intro Œµ hŒµ

  -- diam(I_n) ‚Üí 0 ‚áí ‚àÉ N, ‚àÄ n ‚â• N, diam(I_n) < Œµ
  have ht := diam_tendsto_zero f I‚ÇÄ
  rw [Metric.tendsto_atTop] at ht
  obtain ‚ü®N, hN‚ü© := ht Œµ hŒµ

  refine ‚ü®N, ?_‚ü©
  intro m hm

  -- midpoint distance bound using the interval of index min m N = N
  have hdist := midpoint_dist_bound f I‚ÇÄ m N
  rw [min_eq_right hm] at hdist
  have hd := (hN N (le_rfl))
  have hdm: dist (bisectionMidpoint f I‚ÇÄ m) (bisectionMidpoint f I‚ÇÄ N) = |bisectionMidpoint f I‚ÇÄ m - bisectionMidpoint f I‚ÇÄ N| := by rfl
  rw [dist_zero_right] at hd
  rw [hdm]
  apply lt_of_le_of_lt hdist
  exact lt_of_abs_lt hd

/-- Interval start tends to the bisection midpoint -/
lemma bisection_endpoint_a_converges
    (f : ‚Ñù ‚Üí ‚Ñù) (I‚ÇÄ : Interval) (x : ‚Ñù)
    (hx_lim : Tendsto (fun n => bisectionMidpoint f I‚ÇÄ n) atTop (ùìù x)) :
    Tendsto (fun n => (bisectionInterval f n I‚ÇÄ).a) atTop (ùìù x) := by
  -- Use metric characterization of convergence
  rw [Metric.tendsto_atTop]
  intro Œµ hŒµ

  -- Interval length tends to 0 ‚áí find N‚ÇÅ such that diam(I‚Çô) < Œµ/2
  have hdiam := diam_tendsto_zero f I‚ÇÄ
  rw [Metric.tendsto_atTop] at hdiam
  obtain ‚ü®N‚ÇÅ, hN‚ÇÅ‚ü© := hdiam (Œµ / 2) (by linarith)

  -- Midpoints converge ‚áí find N‚ÇÇ such that |mid‚Çô - x| < Œµ/2
  rw [Metric.tendsto_atTop] at hx_lim
  obtain ‚ü®N‚ÇÇ, hN‚ÇÇ‚ü© := hx_lim (Œµ / 2) (by linarith)

  -- Take N = max N‚ÇÅ N‚ÇÇ
  refine ‚ü®max N‚ÇÅ N‚ÇÇ, ?_‚ü©
  intro n hn

  set I‚Çô := bisectionInterval f n I‚ÇÄ
  set a‚Çô := I‚Çô.a
  set mid‚Çô := bisectionMidpoint f I‚ÇÄ n

  -- 1. a‚Çô ‚â§ mid‚Çô always
  have ha_le_mid : a‚Çô ‚â§ mid‚Çô := by
    dsimp [a‚Çô, mid‚Çô, I‚Çô, bisectionMidpoint, midpoint]
    exact interval_left_le_midpoint _

  -- 2. |a‚Çô - x| ‚â§ |a‚Çô - mid‚Çô| + |mid‚Çô - x|   (triangle inequality)
  have htri : dist a‚Çô x ‚â§ dist a‚Çô mid‚Çô + dist mid‚Çô x := dist_triangle a‚Çô mid‚Çô x

  -- 3. Bound |a‚Çô - mid‚Çô| ‚â§ intervalLength(I‚Çô)
  --    (midpoint lies inside interval)
  have hdistm : dist a‚Çô mid‚Çô ‚â§ intervalLength I‚Çô := by
    dsimp only [dist, intervalLength]
    -- a‚Çô ‚â§ mid‚Çô, so a‚Çô - mid‚Çô ‚â§ 0, hence |a‚Çô - mid‚Çô| = mid‚Çô - a‚Çô
    have hnonpos : a‚Çô - mid‚Çô ‚â§ 0 := by linarith [I‚Çô.h]
    rw [abs_of_nonpos hnonpos]
    simp [a‚Çô]
    apply interval_midpoint_le_right

  -- 4. For n ‚â• N‚ÇÅ ‚áí intervalLength(I‚Çô) < Œµ/2
  have hI_len : intervalLength I‚Çô < Œµ / 2 := by
    have hnn : dist (intervalLength (bisectionInterval f n I‚ÇÄ)) 0 < Œµ / 2 := hN‚ÇÅ n (le_of_max_le_left hn)
    rw [dist_zero_right] at hnn
    exact lt_of_abs_lt hnn

  -- 5. For n ‚â• N‚ÇÇ ‚áí |mid‚Çô - x| < Œµ/2
  have hmid : dist mid‚Çô x < Œµ / 2 := by
    apply hN‚ÇÇ n
    exact le_trans (le_max_right N‚ÇÅ N‚ÇÇ) hn

  -- 6. Final estimate:
  --    dist(a‚Çô, x) ‚â§ dist(a‚Çô, mid‚Çô) + dist(mid‚Çô, x) < Œµ/2 + Œµ/2 = Œµ
  have hsum : dist a‚Çô mid‚Çô + dist mid‚Çô x < Œµ := by linarith

  exact lt_of_le_of_lt htri hsum

/-- Interval end tends to the bisection midpoint -/
lemma bisection_endpoint_b_converges (f : ‚Ñù ‚Üí ‚Ñù) (I‚ÇÄ : Interval) (x : ‚Ñù)
  (hx_lim : Tendsto (fun n => bisectionMidpoint f I‚ÇÄ n) atTop (ùìù x)) :
  Tendsto (fun n => (bisectionInterval f n I‚ÇÄ).b) atTop (ùìù x) := by
  -- Use metric characterization of convergence
  rw [Metric.tendsto_atTop]
  intro Œµ hŒµ

  -- Interval length tends to 0 ‚áí find N‚ÇÅ such that diam(I‚Çô) < Œµ/2
  have hdiam := diam_tendsto_zero f I‚ÇÄ
  rw [Metric.tendsto_atTop] at hdiam
  obtain ‚ü®N‚ÇÅ, hN‚ÇÅ‚ü© := hdiam (Œµ / 2) (by linarith)

  -- Midpoints converge ‚áí find N‚ÇÇ such that |mid‚Çô - x| < Œµ/2
  rw [Metric.tendsto_atTop] at hx_lim
  obtain ‚ü®N‚ÇÇ, hN‚ÇÇ‚ü© := hx_lim (Œµ / 2) (by linarith)

  -- Take N = max N‚ÇÅ N‚ÇÇ
  refine ‚ü®max N‚ÇÅ N‚ÇÇ, ?_‚ü©
  intro n hn

  set I‚Çô := bisectionInterval f n I‚ÇÄ
  set b‚Çô := I‚Çô.b
  set mid‚Çô := bisectionMidpoint f I‚ÇÄ n

  -- 1. mid‚Çô ‚â§ b‚Çô always
  have hmid_le_b : mid‚Çô ‚â§ b‚Çô := by
    dsimp [b‚Çô, mid‚Çô, I‚Çô, bisectionMidpoint, midpoint]
    exact interval_midpoint_le_right _

  -- 2. |b‚Çô - x| ‚â§ |b‚Çô - mid‚Çô| + |mid‚Çô - x|   (triangle inequality)
  have htri : dist b‚Çô x ‚â§ dist b‚Çô mid‚Çô + dist mid‚Çô x := dist_triangle b‚Çô mid‚Çô x

  -- 3. Bound |b‚Çô - mid‚Çô| ‚â§ intervalLength(I‚Çô)
  --    (midpoint lies inside interval)
  have hdistm : dist b‚Çô mid‚Çô ‚â§ intervalLength I‚Çô := by
    dsimp only [dist, intervalLength]
    -- mid‚Çô ‚â§ b‚Çô , so 0 ‚â§ b‚Çô - mid‚Çô, hence |b‚Çô - mid‚Çô| = b‚Çô - mid‚Çô
    have hpos : 0 ‚â§ b‚Çô - mid‚Çô  := by linarith
    rw [abs_of_nonneg hpos]
    refine tsub_le_tsub_left ?_ b‚Çô
    apply interval_left_le_midpoint _

  -- 4. For n ‚â• N‚ÇÅ ‚áí intervalLength(I‚Çô) < Œµ/2
  have hI_len : intervalLength I‚Çô < Œµ / 2 := by
    have hnn : dist (intervalLength (bisectionInterval f n I‚ÇÄ)) 0 < Œµ / 2 := hN‚ÇÅ n (le_of_max_le_left hn)
    rw [dist_zero_right] at hnn
    exact lt_of_abs_lt hnn

  -- 5. For n ‚â• N‚ÇÇ ‚áí |mid‚Çô - x| < Œµ/2
  have hmid : dist mid‚Çô x < Œµ / 2 := by
    apply hN‚ÇÇ n
    exact le_trans (le_max_right N‚ÇÅ N‚ÇÇ) hn

  -- 6. Final estimate:
  --    dist(b‚Çô, x) ‚â§ dist(b‚Çô, mid‚Çô) + dist(mid‚Çô, x) < Œµ/2 + Œµ/2 = Œµ
  have hsum : dist b‚Çô mid‚Çô + dist mid‚Çô x < Œµ := by linarith

  exact lt_of_le_of_lt htri hsum

/-- For the sequence of left endpoints produced by the bisection method, the function values
    `f(a‚Çô)` converge to the value of `f` at the limit point of `a‚Çô`. -/
lemma bisection_fa_endpoint_converges (f : ‚Ñù ‚Üí ‚Ñù) (hcont : Continuous f)
  (I‚ÇÄ : Interval) (x : ‚Ñù)
  (ha_conv : Tendsto (fun n => (bisectionInterval f n I‚ÇÄ).a) atTop (ùìù x)) :
  Tendsto (fun n => f (bisectionInterval f n I‚ÇÄ).a) atTop (ùìù (f x)) := by
  exact Continuous.tendsto hcont x |>.comp ha_conv

/-- For the sequence of right endpoints produced by the bisection method, the function values
    `f(b‚Çô)` converge to the value of `f` at the limit point of `b‚Çô`. -/
lemma bisection_fb_endpoint_converges (f : ‚Ñù ‚Üí ‚Ñù) (hcont : Continuous f)
  (I‚ÇÄ : Interval) (x : ‚Ñù)
  (hb_conv : Tendsto (fun n => (bisectionInterval f n I‚ÇÄ).b) atTop (ùìù x)) :
  Tendsto (fun n => f (bisectionInterval f n I‚ÇÄ).b) atTop (ùìù (f x)) := by
  exact Continuous.tendsto hcont x |>.comp hb_conv

/-- The limit of the products `f a‚Çô * f b‚Çô` in the bisection method is the square of the bisection midpoint. -/
lemma bisection_product_limit (f : ‚Ñù ‚Üí ‚Ñù) (I‚ÇÄ : Interval) (x : ‚Ñù)
  (fa_conv : Tendsto (fun n => f (bisectionInterval f n I‚ÇÄ).a) atTop (ùìù (f x)))
  (fb_conv : Tendsto (fun n => f (bisectionInterval f n I‚ÇÄ).b) atTop (ùìù (f x))) :
  Tendsto (fun n => f (bisectionInterval f n I‚ÇÄ).a * f (bisectionInterval f n I‚ÇÄ).b) 
    atTop (ùìù (f x * f x)) := by
  exact Tendsto.mul fa_conv fb_conv

/-- In the limit of the bisection method, `f x ^ 2 ‚â§ 0`, a key step implying `f x = 0`. -/
lemma bisection_fx_squared_nonpos (f : ‚Ñù ‚Üí ‚Ñù) (I‚ÇÄ : Interval)
  (sign_pres : ‚àÄ n, f (bisectionInterval f n I‚ÇÄ).a * f (bisectionInterval f n I‚ÇÄ).b ‚â§ 0)
  (prod_conv : Tendsto (fun n => f (bisectionInterval f n I‚ÇÄ).a * f (bisectionInterval f n I‚ÇÄ).b) 
    atTop (ùìù (f x * f x))) :
  f x * f x ‚â§ 0 := by
  apply le_of_tendsto prod_conv
  filter_upwards with n
  exact sign_pres n

/--
The bisection midpoint sequence converges to the unique point in the nested
interval intersection, which is a root of `f`.
-/
theorem bisection_converges
    {I‚ÇÄ : Interval} (f : ‚Ñù ‚Üí ‚Ñù)
    (hcont : Continuous f)
    (hroot : f I‚ÇÄ.a * f I‚ÇÄ.b ‚â§ 0) :
    ‚àÉ x,
      Tendsto (fun n => bisectionMidpoint f I‚ÇÄ n) atTop (ùìù x)
      ‚àß f x = 0 := by
  have cauchy := bisection_cauchy f I‚ÇÄ
  obtain ‚ü®x, hx_lim‚ü© := cauchySeq_tendsto_of_complete cauchy
  use x
  constructor
  ¬∑ exact hx_lim
  ¬∑ -- Show f x = 0
    have sign_pres := bisectionStep_preserve_sign_change_inductive f I‚ÇÄ hroot
    have a_conv := bisection_endpoint_a_converges f I‚ÇÄ x hx_lim
    have b_conv := bisection_endpoint_b_converges f I‚ÇÄ x hx_lim
    have fa_conv := bisection_fa_endpoint_converges f hcont I‚ÇÄ x a_conv
    have fb_conv := bisection_fb_endpoint_converges f hcont I‚ÇÄ x b_conv
    have prod_conv := bisection_product_limit f I‚ÇÄ x fa_conv fb_conv
    have fx_sq_nonpos := bisection_fx_squared_nonpos f I‚ÇÄ sign_pres prod_conv
    -- (f x)¬≤ ‚â§ 0, but (f x)¬≤ ‚â• 0, so (f x)¬≤ = 0, hence f x = 0
    have fx_sq_nonneg : 0 ‚â§ f x * f x := mul_self_nonneg (f x)
    have : f x * f x = 0 := le_antisymm fx_sq_nonpos fx_sq_nonneg
    exact mul_self_eq_zero.mp this

end Convergence


/-! ## Quantitative Bounds -/

/-- Nestedness: the bisection intervals form a decreasing sequence of sets.
    If `k ‚â§ m`, then the m-th bisection interval is contained in the k-th. -/
lemma nested_intervals_preserve_containment
    {f : ‚Ñù ‚Üí ‚Ñù} (I : Interval) :
    ‚àÄ {k m : ‚Ñï}, k ‚â§ m ‚Üí
      IccOfInterval (bisectionInterval f m I)
        ‚äÜ IccOfInterval (bisectionInterval f k I) :=
by
  intro k m hkm
  exact bisectionInterval_subset_of_le I hkm

/-- After `n` steps, the bisection approximation differs from any root
in the initial interval by at most `(b‚ÇÄ - a‚ÇÄ) / 2^(n+1)`. -/
lemma bisection_error_bound
  {f : ‚Ñù ‚Üí ‚Ñù} {I : Interval}
  (n : ‚Ñï)
  {r : ‚Ñù}
  (hr : r ‚àà IccOfInterval (bisectionInterval f n I)) :
  |bisectionMidpoint f I n - r| ‚â§ intervalLength I / 2^(n+1) := by
  
  -- Let I‚Çô be the nth interval
  set I‚Çô := bisectionInterval f n I
  set b‚Çô := I‚Çô.b
  set a‚Çô := I‚Çô.a

  simp [IccOfInterval] at hr

  have hxy :
      |bisectionMidpoint f I n - r| ‚â§ intervalLength I‚Çô / 2 := by
    apply abs_le.mpr
    constructor
    all_goals (simp only [bisectionMidpoint, intervalLength, midpoint, I‚Çô]; linarith)

  have hfinal : |bisectionMidpoint f I n - r| ‚â§ intervalLength I / 2^(n+1) := by
    have hle : intervalLength I / 2^(n+1) = intervalLength I / 2^n / 2 := by ring_nf
    simp only [intervalLength_bisectionInterval f I n, I‚Çô] at hxy
    exact le_of_le_of_eq hxy (id (Eq.symm hle))

  exact hfinal

end Numerical
