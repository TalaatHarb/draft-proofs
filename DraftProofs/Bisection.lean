/-
# Numerical Analysis: The Bisection Method

This file develops the classical **bisection root-finding method** for continuous
real functions. It contains:

* A definition of a single bisection step
* The recursive sequence of bisection intervals
* Midpoints of these intervals
* A proof that interval lengths shrink to zero
* Convergence of the midpoint sequence to a root
* A quantitative error bound after `n` iterations

This is structured according to mathlib conventions and is intended as a starting
point for a full formalization.
-/

import Mathlib.Topology.Basic
import Mathlib.Data.Real.Basic
import Mathlib.Analysis.Calculus.MeanValue
import Mathlib.Analysis.SpecialFunctions.Pow.Real

open scoped Topology
open Filter

noncomputable section

namespace Numerical

structure Interval where
  a : ‚Ñù
  b : ‚Ñù
  h : a ‚â§ b

@[simp] def midpoint (I : Interval) : ‚Ñù := (I.a + I.b) / 2

def IccOfInterval (I : Interval) : Set ‚Ñù := Set.Icc I.a I.b

/-! ## Bisection Step -/

/-- A single bisection step: given a function `f` and an interval `[a, b]`
with a sign change, return the next subinterval containing the root. -/
def bisectionStep (f : ‚Ñù ‚Üí ‚Ñù) (I : Interval) : Interval :=
  if h : f I.a * f (midpoint I) ‚â§ 0 then
    { a := I.a, b := (midpoint I), h : I.a ‚â§ (midpoint I) := by simp; linarith[I.h] }
  else
    { a := (midpoint I), b := I.b, h : (midpoint I) ‚â§ I.b := by simp; linarith[I.h] }

/-- Length of a real interval. -/
@[simp] def intervalLength (I : Interval) : ‚Ñù := I.b - I.a

/-! ## Recursive interval sequence -/

/-- The `n`-th interval generated by the bisection method. -/
def bisectionInterval (f : ‚Ñù ‚Üí ‚Ñù) : ‚Ñï ‚Üí Interval ‚Üí Interval
  | 0,   I  => I
  | n+1, I  =>
      let next := bisectionStep f I
      bisectionInterval f n next

/-- The midpoint of the `n`-th bisection interval. -/
def bisectionMidpoint (f : ‚Ñù ‚Üí ‚Ñù) (I : Interval) (n : ‚Ñï) : ‚Ñù :=
  let In := bisectionInterval f n I
  (In.a + In.b) / 2


/-! ## Interval-shrinking lemmas -/

section IntervalShrink

lemma interval_left_le_midpoint (I: Interval) : I.a ‚â§ midpoint I := by
  simp
  linarith [I.h]

lemma interval_midpoint_le_right (I: Interval) : midpoint I ‚â§ I.b := by
  simp
  linarith [I.h]

/-- The interval length after one bisection step is half the original. -/
lemma intervalLength_bisectionStep (f : ‚Ñù ‚Üí ‚Ñù) (I: Interval):
    intervalLength (bisectionStep f I) = (I.b - I.a) / 2 := by
  dsimp [bisectionStep, intervalLength]
  by_cases h : f I.a * f (midpoint I) ‚â§ 0
  all_goals
  ¬∑ split
    all_goals
    ring_nf


lemma intervalLength_bisectionInterval (f : ‚Ñù ‚Üí ‚Ñù) (I : Interval) :
  ‚àÄ n : ‚Ñï, intervalLength (bisectionInterval f n I) = intervalLength I / 2^n
:= by
  intro n
  induction n generalizing I with
  | zero => simp [bisectionInterval, intervalLength, pow_zero]
  | succ n ih =>
    -- let J be the interval after one bisection step
    let J := bisectionStep f I
    -- Apply the inductive hypothesis to J (not I!)
    have ihJ : intervalLength (bisectionInterval f n J) = intervalLength J / 2^n := by exact ih J
    simp only [bisectionInterval]
    rw [ihJ]
    -- Now we need: intervalLength J / 2^n = intervalLength (a, b) / 2^(n+1)
    rw [intervalLength_bisectionStep]
    -- We have: ((b - a) / 2) / 2^n = (b - a) / 2^(n+1)
    simp [intervalLength, pow_succ]
    ring_nf



/-- The interval diameters tend to zero as `n ‚Üí ‚àû`. -/
lemma diam_tendsto_zero (f : ‚Ñù ‚Üí ‚Ñù) (I : Interval) :
  Tendsto (fun n => intervalLength (bisectionInterval f n I))
          atTop (ùìù 0) := by
  simp_rw [intervalLength_bisectionInterval]
  have hs : (fun n => intervalLength I / 2 ^ n) = 
         (fun n => intervalLength I * (1 / 2) ^ n) := by
    ext n
    simp
    ring_nf
  rw [hs]
  have hpow : Tendsto (fun n => (1 / 2 : ‚Ñù) ^ n) atTop (ùìù 0) := by
    apply tendsto_pow_atTop_nhds_zero_of_lt_one
    ¬∑ norm_num
    ¬∑ norm_num
  convert Tendsto.const_mul (intervalLength I) hpow using 1
  simp

end IntervalShrink


/-! ## Convergence of the bisection method -/

section Convergence

/-- Helper lemma: midpoints of nested intervals stay within bounds -/
lemma midpoint_in_interval (f : ‚Ñù ‚Üí ‚Ñù) (I : Interval) (n : ‚Ñï) :
    have {a:= a‚ÇÄ, b:= b‚ÇÄ, h:= _} := I
    have {a:= a‚Çô, b:= b‚Çô, h:= _} := bisectionInterval f n I
    a‚ÇÄ ‚â§ a‚Çô ‚àß a‚Çô ‚â§ b‚Çô ‚àß b‚Çô ‚â§ b‚ÇÄ := by
    constructor
    . induction n generalizing I with
      | zero => simp [bisectionInterval]
      | succ n ih => 
      simp [bisectionInterval]
      . have ihJ := ih (bisectionStep f I)
        have hi : I.a ‚â§ (bisectionStep f I).a := by      
          -- bisection always shrinks toward the middle:
          -- The new 'a' is either I.a or midpoint(I), both ‚â• I.a
          rw [bisectionStep]
          by_cases hfp : f I.a * f (midpoint I) ‚â§ 0
          ¬∑ -- left interval: new a = old a
            split
            . simp
            . contradiction
          ¬∑ -- right interval: new a = midpoint ‚â• a
            split
            . contradiction
            . simp; linarith [I.h]
        apply le_trans hi
        exact ihJ
    . constructor
      . exact (bisectionInterval f n I).h
      . induction n generalizing I with
      | zero => simp [bisectionInterval]
      | succ n ih => 
      simp [bisectionInterval]
      . have ihJ := ih (bisectionStep f I)
        have hi :  (bisectionStep f I).b ‚â§ I.b := by      
          -- bisection always shrinks toward the middle:
          -- The new 'a' is either I.a or midpoint(I), both ‚â• I.a
          rw [bisectionStep]
          by_cases hfp : f I.a * f (midpoint I) ‚â§ 0
          ¬∑ -- left interval: new a = old a
            split
            . simp; linarith [I.h]
            . contradiction
          ¬∑ -- right interval: new a = midpoint ‚â• a
            split
            . contradiction
            . simp
        apply le_trans ihJ
        exact hi

/-- The interval produced by one bisection step is contained in the original interval. -/
lemma bisectionStep_subset (f : ‚Ñù ‚Üí ‚Ñù) (I : Interval) :
  IccOfInterval (bisectionStep f I) ‚äÜ IccOfInterval I := by
  -- expand definitions and do a case split on the `if` in `bisectionStep`
  dsimp [bisectionStep, IccOfInterval, midpoint]
  by_cases h : f I.a * f (midpoint I) ‚â§ 0
  ¬∑ -- left branch: interval is [I.a, m]
    split
    . -- show {x | I.a ‚â§ x ‚àß x ‚â§ m} ‚äÜ {x | I.a ‚â§ x ‚àß x ‚â§ I.b}
      intro x hx
      exact ‚ü®hx.1, le_trans hx.2 (interval_midpoint_le_right I)‚ü©
    . -- show {x | I.a ‚â§ x ‚àß x ‚â§ m} ‚äÜ {x | I.a ‚â§ x ‚àß x ‚â§ I.b}
      intro x hx
      exact ‚ü®le_trans (interval_left_le_midpoint I) hx.1, hx.2‚ü©
  ¬∑ -- right branch: interval is [m, I.b]
    split
    . -- show {x | I.a ‚â§ x ‚àß x ‚â§ m} ‚äÜ {x | I.a ‚â§ x ‚àß x ‚â§ I.b}
      intro x hx
      exact ‚ü®hx.1, le_trans hx.2 (interval_midpoint_le_right I)‚ü©
    . -- show {x | I.a ‚â§ x ‚àß x ‚â§ m} ‚äÜ {x | I.a ‚â§ x ‚àß x ‚â§ I.b}
      intro x hx
      exact ‚ü®le_trans (interval_left_le_midpoint I) hx.1, hx.2‚ü©

/-- One-step monotonicity: the (n+1)-th interval is contained in the n-th interval,
    for any starting interval `J`. This is proved by induction on `n`, generalized
    over the starting interval. -/
lemma bisectionInterval_one_step_subset (f : ‚Ñù ‚Üí ‚Ñù) :
  ‚àÄ n (J : Interval), (IccOfInterval (bisectionInterval f (n + 1) J)) ‚äÜ (IccOfInterval (bisectionInterval f n J)) := by
  intro n J
  induction n generalizing J with
  | zero =>
    -- bisectionInterval f 1 J = bisectionStep f J and bisectionInterval f 0 J = J
    simp [bisectionInterval]
    exact bisectionStep_subset f J
  | succ n ih =>
    -- bisectionInterval f (n+2) J = bisectionInterval f (n+1) (bisectionStep f J)
    simp [bisectionInterval]
    -- apply IH to the starting interval `bisectionStep f J`
    exact ih (bisectionStep f J)

lemma bisectionInterval_subset_of_le {f : ‚Ñù ‚Üí ‚Ñù} (I : Interval) :
  ‚àÄ {k m : ‚Ñï}, k ‚â§ m -> (IccOfInterval (bisectionInterval f m I)) ‚äÜ (IccOfInterval (bisectionInterval f k I)) := by
  intros k m hk
  obtain ‚ü®t, rfl‚ü© := (le_iff_exists_add.1 hk)  -- m = k + t
  induction t with
  | zero => simp
  | succ t ih =>
    -- I_{k + t + 1} ‚äÜ I_{k + t} by one-step monotonicity, then use IH
    have step_sub := bisectionInterval_one_step_subset f (k + t) I
    exact (step_sub.trans (ih (Nat.le_add_right k t)) : _)

lemma midpoint_dist_bound (f : ‚Ñù ‚Üí ‚Ñù) (I : Interval) (m n : ‚Ñï) :
  |bisectionMidpoint f I m - bisectionMidpoint f I n| ‚â§
    intervalLength (bisectionInterval f (min m n) I) := by
  -- Set k = min m n
  let k := min m n
  have hk_m : k ‚â§ m := Nat.min_le_left _ _
  have hk_n : k ‚â§ n := Nat.min_le_right _ _

  -- Midpoint m lies in interval m
  have mid_m_in_m :
      bisectionMidpoint f I m ‚àà IccOfInterval (bisectionInterval f m I) := by
    let J := bisectionInterval f m I
    dsimp [bisectionMidpoint, midpoint]
    have h1 : J.a ‚â§ (J.a + J.b)/2 := by linarith [J.h]
    have h2 : (J.a + J.b)/2 ‚â§ J.b := by linarith
    exact ‚ü®h1, h2‚ü©

  -- Midpoint n lies in interval n
  have mid_n_in_n :
      bisectionMidpoint f I n ‚àà IccOfInterval (bisectionInterval f n I) := by
    let J := bisectionInterval f n I
    dsimp [bisectionMidpoint, midpoint]
    have h1 : J.a ‚â§ (J.a + J.b)/2 := by linarith [J.h]
    have h2 : (J.a + J.b)/2 ‚â§ J.b := by linarith
    exact ‚ü®h1, h2‚ü©

  -- interval m ‚äÜ interval k because k ‚â§ m
  have sub_mk :
      IccOfInterval (bisectionInterval f m I) ‚äÜ
      IccOfInterval (bisectionInterval f k I) :=
    bisectionInterval_subset_of_le I hk_m

  -- interval n ‚äÜ interval k because k ‚â§ n
  have sub_nk :
      IccOfInterval (bisectionInterval f n I) ‚äÜ
      IccOfInterval (bisectionInterval f k I) :=
    bisectionInterval_subset_of_le I hk_n

  -- Therefore both midpoints lie in interval k
  have mid_m_in_k : bisectionMidpoint f I m ‚àà IccOfInterval (bisectionInterval f k I) :=
    sub_mk mid_m_in_m
  have mid_n_in_k : bisectionMidpoint f I n ‚àà IccOfInterval (bisectionInterval f k I) :=
    sub_nk mid_n_in_n

  -- Unpack interval k
  -- Let Jk be the k-th interval
  set Jk := bisectionInterval f k I with hJk

  -- rewrite the midpoint memberships
  simp [hJk, IccOfInterval] at mid_m_in_k mid_n_in_k

  apply abs_le.2
  constructor
  all_goals
  . simp [Jk]
    linarith

/-- The bisection step preserves the sign-change property:
    if f a * f b ‚â§ 0 then the new endpoints also have product ‚â§ 0. -/
lemma bisectionStep_preserve_sign_change {f : ‚Ñù ‚Üí ‚Ñù} (I : Interval)
  (h : f I.a * f I.b ‚â§ 0) :
  f (bisectionStep f I).a * f (bisectionStep f I).b ‚â§ 0 := by
  dsimp [bisectionStep, midpoint]
  by_cases hmid : f I.a * f ((I.a + I.b) / 2) ‚â§ 0
  ¬∑ -- left branch: (a, midpoint)
    simp [hmid]
  ¬∑ -- right branch: (midpoint, b)
    simp [hmid]
    -- in this branch we know ¬¨ (f a * f m ‚â§ 0), i.e., f a * f m > 0,
    -- so f a and f m have the same sign. Since f a * f b ‚â§ 0,
    -- f m * f b ‚â§ 0 follows.
    have hab := h
    -- rewrite hmid as a strict > 0 inequality
    have hpos : 0 < f I.a * f ((I.a + I.b) / 2) := by
      simp at hmid
      exact hmid
    -- from positivity of (f a * f m) we get sign(f a) = sign(f m) (or both zero is excluded)
    -- but we avoid sign reasoning: multiply `hpos` and `hab` gives (f a * f m) * (f a * f b) ‚â§ 0,
    -- we can cancel `f a` if nonzero, but simpler: use cases on f I.a = 0
    by_cases fa0 : f I.a = 0
    ¬∑ -- if f a = 0 then f m * f b = 0 ‚â§ 0
      rw [fa0, zero_mul] at hpos
      norm_num at hpos
    ¬∑
      -- f a ‚â† 0, divide inequalities by f a (preserving direction when positive/negative)
      -- Transform hpos : 0 < f a * f m  ‚Üí (f m) * sign(f a) > 0; but we can reason:
      -- from hpos and fa0 we get 0 < f m * (f a) so sign(f m) = sign(f a).
      -- Since f a * f b ‚â§ 0, we have f m * f b ‚â§ 0 as required.
      have : f I.a ‚â† 0 := fa0
      -- multiply hab (‚â§0) by the sign of f a to transfer sign: we use `mul_le_mul_left'`
      -- A direct and robust approach: consider (f I.a) * (f I.b) ‚â§ 0 and (f I.a) * (f ((I.a + I.b)/2)) > 0.
      -- If f I.a > 0 then f ((I.a + I.b)/2) > 0 and from hab we get f ((I.a + I.b)/2) * f I.b ‚â§ 0.
      cases lt_or_gt_of_ne this with
      -- f a > 0
      | inr =>
        have hfb : f I.b ‚â§ 0 := by
          apply nonpos_of_mul_nonpos_right h
          assumption
        have hfab : 0 ‚â§ f ((I.a + I.b) / 2) := by
          rw [mul_comm] at hpos
          have hp := (pos_of_mul_pos_left hpos)
          apply le_of_lt
          apply hp
          linarith
        exact mul_nonpos_of_nonneg_of_nonpos hfab hfb
      -- f a < 0
      | inl =>
        have hfb : 0 ‚â§ f I.b := by
          apply nonneg_of_mul_nonpos_right h
          assumption
        have hfab : f ((I.a + I.b) / 2) ‚â§ 0 := by
          have hp := (neg_of_mul_pos_right hpos)
          apply le_of_lt
          apply hp
          linarith
        exact mul_nonpos_of_nonpos_of_nonneg hfab hfb

lemma bisectionStep_preserve_sign_change_inductive
    (f : ‚Ñù ‚Üí ‚Ñù) (I‚ÇÄ : Interval)
    (hroot : f I‚ÇÄ.a * f I‚ÇÄ.b ‚â§ 0) :
    ‚àÄ n,
      f (bisectionInterval f n I‚ÇÄ).a *
      f (bisectionInterval f n I‚ÇÄ).b ‚â§ 0 := by
  intro n
  induction n with
  | zero =>
      simpa [bisectionInterval] using hroot

  | succ n ih =>
      -- Expand definition of bisectionInterval (n+1)
      -- (bisectionInterval f (n+1) I‚ÇÄ = bisectionStep f (bisectionInterval f n I‚ÇÄ))
      simp [bisectionInterval]

      -- Now apply the one-step preservation lemma
      have h:= bisectionStep_preserve_sign_change (bisectionInterval f n I‚ÇÄ) ih
      have hn : bisectionStep f (bisectionInterval f n I‚ÇÄ) = bisectionInterval f n (bisectionStep f I‚ÇÄ) := by
        induction n with
        | zero =>
            -- Base case: n = 0
            -- bisectionInterval f 0 I‚ÇÄ = I‚ÇÄ
            -- bisectionInterval f 0 (bisectionStep f I‚ÇÄ) = bisectionStep f I‚ÇÄ
            simp [bisectionInterval]
      
        | succ n ih =>
            -- Inductive step
            -- Expand definition of (n+1)-th interval on both sides
            simp [bisectionInterval]
            sorry
      
      rw [hn] at h
      assumption



lemma bisection_cauchy (f : ‚Ñù ‚Üí ‚Ñù) (I‚ÇÄ : Interval) :
  CauchySeq (fun n => bisectionMidpoint f I‚ÇÄ n) := by
  -- Use the metric Cauchy characterization
  apply Metric.cauchySeq_iff'.mpr
  intro Œµ hŒµ

  -- diam(I_n) ‚Üí 0 ‚áí ‚àÉ N, ‚àÄ n ‚â• N, diam(I_n) < Œµ
  have ht := diam_tendsto_zero f I‚ÇÄ
  rw [Metric.tendsto_atTop] at ht
  obtain ‚ü®N, hN‚ü© := ht Œµ hŒµ

  refine ‚ü®N, ?_‚ü©
  intro m hm

  -- midpoint distance bound using the interval of index min m N = N
  have hdist :=
    midpoint_dist_bound f I‚ÇÄ m N

  have hmin : min m N = N := by
    exact min_eq_right hm

  rw [hmin] at hdist
  have hd := (hN N (le_rfl))
  -- Rewrite intervalLength(min) using hmin
  
  
  sorry



lemma bisection_endpoint_a_converges
    (f : ‚Ñù ‚Üí ‚Ñù) (I‚ÇÄ : Interval) (x : ‚Ñù)
    (hx_lim : Tendsto (fun n => bisectionMidpoint f I‚ÇÄ n) atTop (ùìù x)) :
    Tendsto (fun n => (bisectionInterval f n I‚ÇÄ).a) atTop (ùìù x) := by
  -- Use metric characterization of convergence
  rw [Metric.tendsto_atTop]
  intro Œµ hŒµ

  -- Interval length tends to 0 ‚áí find N‚ÇÅ such that diam(I‚Çô) < Œµ/2
  have hdiam := diam_tendsto_zero f I‚ÇÄ
  rw [Metric.tendsto_atTop] at hdiam
  obtain ‚ü®N‚ÇÅ, hN‚ÇÅ‚ü© := hdiam (Œµ / 2) (by linarith)

  -- Midpoints converge ‚áí find N‚ÇÇ such that |mid‚Çô - x| < Œµ/2
  rw [Metric.tendsto_atTop] at hx_lim
  obtain ‚ü®N‚ÇÇ, hN‚ÇÇ‚ü© := hx_lim (Œµ / 2) (by linarith)

  -- Take N = max N‚ÇÅ N‚ÇÇ
  refine ‚ü®max N‚ÇÅ N‚ÇÇ, ?_‚ü©
  intro n hn

  set I‚Çô := bisectionInterval f n I‚ÇÄ
  set a‚Çô := I‚Çô.a
  set mid‚Çô := bisectionMidpoint f I‚ÇÄ n

  -- 1. a‚Çô ‚â§ mid‚Çô always
  have ha_le_mid : a‚Çô ‚â§ mid‚Çô := by
    dsimp [a‚Çô, mid‚Çô, I‚Çô, bisectionMidpoint, midpoint]
    exact interval_left_le_midpoint _

  -- 2. |a‚Çô - x| ‚â§ |a‚Çô - mid‚Çô| + |mid‚Çô - x|   (triangle inequality)
  have htri : dist a‚Çô x ‚â§ dist a‚Çô mid‚Çô + dist mid‚Çô x := by
    sorry

  -- 3. Bound |a‚Çô - mid‚Çô| ‚â§ intervalLength(I‚Çô)
  --    (midpoint lies inside interval)
  have h1 : dist a‚Çô mid‚Çô ‚â§ intervalLength I‚Çô := by
    sorry

  -- 4. For n ‚â• N‚ÇÅ ‚áí intervalLength(I‚Çô) < Œµ/2
  have hI_len : intervalLength I‚Çô < Œµ / 2 := by
    sorry

  -- 5. For n ‚â• N‚ÇÇ ‚áí |mid‚Çô - x| < Œµ/2
  have hmid : dist mid‚Çô x < Œµ / 2 := by
    apply hN‚ÇÇ n
    exact le_trans (le_max_right _ _) hn

  -- 6. Final estimate:
  --    dist(a‚Çô, x) ‚â§ dist(a‚Çô, mid‚Çô) + dist(mid‚Çô, x) < Œµ/2 + Œµ/2 = Œµ
  have hsum :
      dist a‚Çô mid‚Çô + dist mid‚Çô x < Œµ := by
    linarith

  exact lt_of_le_of_lt htri hsum


lemma bisection_endpoint_b_converges (f : ‚Ñù ‚Üí ‚Ñù) (I‚ÇÄ : Interval) (x : ‚Ñù)
  (hx_lim : Tendsto (fun n => bisectionMidpoint f I‚ÇÄ n) atTop (ùìù x)) :
  Tendsto (fun n => (bisectionInterval f n I‚ÇÄ).b) atTop (ùìù x) := by
  rw [Metric.tendsto_atTop]
  intro Œµ hŒµ
  have hdiam := diam_tendsto_zero f I‚ÇÄ
  rw [Metric.tendsto_atTop] at hdiam
  obtain ‚ü®N‚ÇÅ, hN‚ÇÅ‚ü© := hdiam (Œµ / 2) (by linarith)
  rw [Metric.tendsto_atTop] at hx_lim
  obtain ‚ü®N‚ÇÇ, hN‚ÇÇ‚ü© := hx_lim (Œµ / 2) (by linarith)
  use max N‚ÇÅ N‚ÇÇ
  intro n hn
  set I‚Çô := bisectionInterval f n I‚ÇÄ
  set b‚Çô := I‚Çô.b
  set mid‚Çô := bisectionMidpoint f I‚ÇÄ n
  have hmid_le_b : mid‚Çô ‚â§ b‚Çô := by
    dsimp [bisectionMidpoint, midpoint]
    exact interval_midpoint_le_right I‚Çô
  sorry

lemma bisection_fa_endpoint_converges (f : ‚Ñù ‚Üí ‚Ñù) (hcont : Continuous f)
  (I‚ÇÄ : Interval) (x : ‚Ñù)
  (ha_conv : Tendsto (fun n => (bisectionInterval f n I‚ÇÄ).a) atTop (ùìù x)) :
  Tendsto (fun n => f (bisectionInterval f n I‚ÇÄ).a) atTop (ùìù (f x)) := by
  exact Continuous.tendsto hcont x |>.comp ha_conv

lemma bisection_fb_endpoint_converges (f : ‚Ñù ‚Üí ‚Ñù) (hcont : Continuous f)
  (I‚ÇÄ : Interval) (x : ‚Ñù)
  (hb_conv : Tendsto (fun n => (bisectionInterval f n I‚ÇÄ).b) atTop (ùìù x)) :
  Tendsto (fun n => f (bisectionInterval f n I‚ÇÄ).b) atTop (ùìù (f x)) := by
  exact Continuous.tendsto hcont x |>.comp hb_conv

lemma bisection_product_limit (f : ‚Ñù ‚Üí ‚Ñù) (I‚ÇÄ : Interval) (x : ‚Ñù)
  (fa_conv : Tendsto (fun n => f (bisectionInterval f n I‚ÇÄ).a) atTop (ùìù (f x)))
  (fb_conv : Tendsto (fun n => f (bisectionInterval f n I‚ÇÄ).b) atTop (ùìù (f x))) :
  Tendsto (fun n => f (bisectionInterval f n I‚ÇÄ).a * f (bisectionInterval f n I‚ÇÄ).b) 
    atTop (ùìù (f x * f x)) := by
  exact Tendsto.mul fa_conv fb_conv

lemma bisection_fx_squared_nonpos (f : ‚Ñù ‚Üí ‚Ñù) (I‚ÇÄ : Interval)
  (sign_pres : ‚àÄ n, f (bisectionInterval f n I‚ÇÄ).a * f (bisectionInterval f n I‚ÇÄ).b ‚â§ 0)
  (prod_conv : Tendsto (fun n => f (bisectionInterval f n I‚ÇÄ).a * f (bisectionInterval f n I‚ÇÄ).b) 
    atTop (ùìù (f x * f x))) :
  f x * f x ‚â§ 0 := by
  apply le_of_tendsto prod_conv
  filter_upwards with n
  exact sign_pres n

/--
The bisection midpoint sequence converges to the unique point in the nested
interval intersection, which is a root of `f`.
-/
theorem bisection_converges
    {I‚ÇÄ : Interval} (f : ‚Ñù ‚Üí ‚Ñù)
    (hcont : Continuous f)
    (hroot : f I‚ÇÄ.a * f I‚ÇÄ.b ‚â§ 0) :
    ‚àÉ x,
      Tendsto (fun n => bisectionMidpoint f I‚ÇÄ n) atTop (ùìù x)
      ‚àß f x = 0 := by
  have cauchy := bisection_cauchy f I‚ÇÄ
  obtain ‚ü®x, hx_lim‚ü© := cauchySeq_tendsto_of_complete cauchy
  use x
  constructor
  ¬∑ exact hx_lim
  ¬∑ -- Show f x = 0
    have sign_pres := bisectionStep_preserve_sign_change_inductive f I‚ÇÄ hroot
    have a_conv := bisection_endpoint_a_converges f I‚ÇÄ x hx_lim
    have b_conv := bisection_endpoint_b_converges f I‚ÇÄ x hx_lim
    have fa_conv := bisection_fa_endpoint_converges f hcont I‚ÇÄ x a_conv
    have fb_conv := bisection_fb_endpoint_converges f hcont I‚ÇÄ x b_conv
    have prod_conv := bisection_product_limit f I‚ÇÄ x fa_conv fb_conv
    have fx_sq_nonpos := bisection_fx_squared_nonpos f I‚ÇÄ sign_pres prod_conv
    -- (f x)¬≤ ‚â§ 0, but (f x)¬≤ ‚â• 0, so (f x)¬≤ = 0, hence f x = 0
    have fx_sq_nonneg : 0 ‚â§ f x * f x := mul_self_nonneg (f x)
    have : f x * f x = 0 := le_antisymm fx_sq_nonpos fx_sq_nonneg
    exact mul_self_eq_zero.mp this

end Convergence


/-! ## Quantitative Bounds -/

/-- Helper: nested intervals preserve containment -/
lemma nested_intervals_preserve_containment (f : ‚Ñù ‚Üí ‚Ñù) (I : Interval) (n : ‚Ñï) :
    ‚àÄ x, x ‚àà Set.Icc I.a I.b ‚Üí 
    have {a:= a‚Çô, b:= b‚Çô, h:= h‚Çô} := bisectionInterval f n I
    x ‚àà Set.Icc a‚Çô b‚Çô := by
  sorry -- Requires proving bisection maintains sign change property

/-- After `n` steps, the bisection approximation differs from any root
in the initial interval by at most `(b‚ÇÄ - a‚ÇÄ) / 2^(n+1)`. -/
theorem bisection_error_bound
    (f : ‚Ñù ‚Üí ‚Ñù) (I : Interval) (n : ‚Ñï) :
    let x‚Çô := bisectionMidpoint f I n
    have {a:= a‚ÇÄ, b:= b‚ÇÄ, h:= h‚ÇÄ} := I
    ‚àÄ x ‚àà Set.Icc a‚ÇÄ b‚ÇÄ,
      |x‚Çô - x| ‚â§ intervalLength I / (2^(n+1)) := by
  intro x hx  
  -- Let (a‚Çô, b‚Çô) be the n-th interval
  have {a:= a‚Çô, b:= b‚Çô, h:= h‚Çô} := bisectionInterval f n I
  set x‚Çô := (a‚Çô + b‚Çô) / 2
  
  -- Key fact: x must be in [a‚Çô, b‚Çô] (nested intervals preserve the root)
  have x_in_interval : x ‚àà Set.Icc a‚Çô b‚Çô := by
    sorry
  
  -- Therefore |x‚Çô - x| ‚â§ (b‚Çô - a‚Çô) / 2
  have bound_by_half_interval : |x‚Çô - x| ‚â§ (b‚Çô - a‚Çô) / 2 := by
    have hx_le_b : x ‚â§ b‚Çô := x_in_interval.2
    have ha_le_x : a‚Çô ‚â§ x := x_in_interval.1
    rw [abs_sub_le_iff]
    constructor
    ¬∑ -- x‚Çô - x ‚â§ (b‚Çô - a‚Çô) / 2
      have : x‚Çô = (a‚Çô + b‚Çô) / 2 := rfl
      linarith
    ¬∑ -- -(b‚Çô - a‚Çô) / 2 ‚â§ x‚Çô - x
      have : x‚Çô = (a‚Çô + b‚Çô) / 2 := rfl
      linarith
  
  -- Use intervalLength_bisectionInterval: b‚Çô - a‚Çô = (b‚ÇÄ - a‚ÇÄ) / 2^n
  sorry

end Numerical