/-
# Numerical Analysis: The Bisection Method

This file develops the classical **bisection root-finding method** for continuous
real functions. It contains:

* A definition of a single bisection step
* The recursive sequence of bisection intervals
* Midpoints of these intervals
* A proof that interval lengths shrink to zero
* Convergence of the midpoint sequence to a root
* A quantitative error bound after `n` iterations

This is structured according to mathlib conventions and is intended as a starting
point for a full formalization.
-/

import Mathlib.Topology.Basic
import Mathlib.Data.Real.Basic
import Mathlib.Analysis.Calculus.MeanValue
import Mathlib.Analysis.SpecialFunctions.Pow.Real

open scoped Topology
open Filter

noncomputable section

namespace Numerical

/-! ## Bisection Step -/

/-- A single bisection step: given a function `f` and an interval `[a, b]`
with a sign change, return the next subinterval containing the root. -/
def bisectionStep (f : â„ â†’ â„) (a b : â„) : â„ Ã— â„ :=
  let m := (a + b) / 2
  if h : f a * f m â‰¤ 0 then (a, m) else (m, b)

/-- Length of a real interval. -/
@[simp] def intervalLength (I : â„ Ã— â„) : â„ := I.2 - I.1

/-! ## Recursive interval sequence -/

/-- The `n`-th interval generated by the bisection method. -/
def bisectionInterval (f : â„ â†’ â„) : â„• â†’ (â„ Ã— â„) â†’ (â„ Ã— â„)
  | 0,     I     => I
  | n+1, (a, b)  =>
      let next := bisectionStep f a b
      bisectionInterval f n next

/-- The midpoint of the `n`-th bisection interval. -/
def bisectionMidpoint (f : â„ â†’ â„) (I : â„ Ã— â„) (n : â„•) : â„ :=
  let (aâ‚™, bâ‚™) := bisectionInterval f n I
  (aâ‚™ + bâ‚™) / 2


/-! ## Interval-shrinking lemmas -/

section IntervalShrink

/-- The interval length after one bisection step is half the original. -/
lemma intervalLength_bisectionStep (f : â„ â†’ â„) (a b : â„) :
    intervalLength (bisectionStep f a b) = (b - a) / 2 := by
  dsimp [bisectionStep, intervalLength]
  set m : â„ := (a + b) / 2

  by_cases h : f a * f m â‰¤ 0
  Â· -- Case 1: choose interval (a, m)
    simp [h, m]  -- reduces goal to proving: m - a = (b - a)/2
    have : m - a = (b - a) / 2 := by
      simp [m, sub_eq_add_neg, add_comm]
      linarith
    linarith

  Â· -- Case 2: choose interval (m, b)
    simp [h, m]
    have : b - m = (b - a) / 2 := by
      simp [m, sub_eq_add_neg]
      linarith
    linarith


lemma intervalLength_bisectionInterval (f : â„ â†’ â„) (I : â„ Ã— â„) :
  âˆ€ n : â„•, intervalLength (bisectionInterval f n I) = intervalLength I / 2^n
:= by
  intro n
  induction n generalizing I with
  | zero => simp [bisectionInterval, intervalLength, pow_zero]
  | succ n ih =>
    rcases I with âŸ¨a, bâŸ©
    -- by definition of bisectionInterval
    simp only [bisectionInterval]
    -- let J be the interval after one bisection step
    let J := bisectionStep f a b
    -- Apply the inductive hypothesis to J (not I!)
    have ih_J : intervalLength (bisectionInterval f n J) = intervalLength J / 2^n := ih J
    rw [ih_J]
    -- Now we need: intervalLength J / 2^n = intervalLength (a, b) / 2^(n+1)
    rw [intervalLength_bisectionStep]
    -- We have: ((b - a) / 2) / 2^n = (b - a) / 2^(n+1)
    simp [intervalLength, pow_succ]
    ring



/-- The interval diameters tend to zero as `n â†’ âˆž`. -/
lemma diam_tendsto_zero (f : â„ â†’ â„) (I : â„ Ã— â„) :
  Tendsto (fun n => intervalLength (bisectionInterval f n I))
          atTop (ð“ 0) := by
  simp_rw [intervalLength_bisectionInterval]
  sorry

end IntervalShrink


/-! ## Convergence of the bisection method -/

section Convergence

/-- Helper lemma: midpoints of nested intervals stay within bounds -/
lemma midpoint_in_interval (f : â„ â†’ â„) (I : â„ Ã— â„) (n : â„•) :
    let (a, b) := I
    let (aâ‚™, bâ‚™) := bisectionInterval f n I
    a â‰¤ aâ‚™ âˆ§ aâ‚™ â‰¤ bâ‚™ âˆ§ bâ‚™ â‰¤ b := by
  sorry -- This would require additional lemmas about interval nesting

/-- Helper: distance between two midpoints is bounded by interval length -/
lemma midpoint_dist_bound (f : â„ â†’ â„) (I : â„ Ã— â„) (m n : â„•) :
    |bisectionMidpoint f I m - bisectionMidpoint f I n| â‰¤ 
    intervalLength (bisectionInterval f (min m n) I) := by
  sorry -- Follows from both midpoints being in the min-th interval

/--
The bisection midpoint sequence converges to the unique point in the nested
interval intersection, which is a root of `f`.
-/
theorem bisection_converges
    {aâ‚€ bâ‚€ : â„} (f : â„ â†’ â„)
    (hcont : Continuous f)
    (hroot : f aâ‚€ * f bâ‚€ â‰¤ 0) :
    âˆƒ x,
      Tendsto (fun n => bisectionMidpoint f (aâ‚€, bâ‚€) n) atTop (ð“ x)
      âˆ§ f x = 0 := by
  -- The key idea: nested intervals with shrinking diameter
  -- By Cantor's nested interval theorem, the intersection is a single point
  
  -- First, show the sequence is Cauchy
  have cauchy : CauchySeq (fun n => bisectionMidpoint f (aâ‚€, bâ‚€) n) := by
    apply Metric.cauchySeq_iff'.mpr
    intro Îµ hÎµ
    -- Use diam_tendsto_zero to find N where diam < Îµ
    have := diam_tendsto_zero f (aâ‚€, bâ‚€)
    rw [Metric.tendsto_atTop] at this
    obtain âŸ¨N, hNâŸ© := this Îµ hÎµ
    use N
    intro m hm
    -- Show |xâ‚˜ - xâ‚™| â‰¤ diam of interval, which is < Îµ
    sorry
  
  -- Since â„ is complete, Cauchy sequence converges
  obtain âŸ¨x, hxâŸ© := cauchySeq_tendsto_of_complete cauchy
  use x
  constructor
  Â· exact hx
  Â· -- Show f x = 0 by continuity
    -- Each interval contains a sign change
    -- The limit point must be a root
    sorry -- Would need to show:
    -- 1. f preserves sign change at endpoints of each interval
    -- 2. Endpoints converge to x
    -- 3. Therefore f(x) must be zero by continuity

end Convergence


/-! ## Quantitative Bounds -/

/-- Helper: nested intervals preserve containment -/
lemma nested_intervals_preserve_containment (f : â„ â†’ â„) (I : â„ Ã— â„) (n : â„•) :
    âˆ€ x, x âˆˆ Set.Icc I.1 I.2 â†’ 
    let (aâ‚™, bâ‚™) := bisectionInterval f n I
    x âˆˆ Set.Icc aâ‚™ bâ‚™ := by
  sorry -- Requires proving bisection maintains sign change property

/-- After `n` steps, the bisection approximation differs from any root
in the initial interval by at most `(bâ‚€ - aâ‚€) / 2^(n+1)`. -/
theorem bisection_error_bound
    (f : â„ â†’ â„) (I : â„ Ã— â„) (n : â„•) :
    let xâ‚™ := bisectionMidpoint f I n
    let (aâ‚€, bâ‚€) := I
    âˆ€ x âˆˆ Set.Icc aâ‚€ bâ‚€,
      |xâ‚™ - x| â‰¤ intervalLength I / (2^(n+1)) := by
  intro x hx
  rcases I with âŸ¨aâ‚€, bâ‚€âŸ©
  
  -- Let (aâ‚™, bâ‚™) be the n-th interval
  obtain âŸ¨aâ‚™, bâ‚™âŸ© := bisectionInterval f n (aâ‚€, bâ‚€)
  set xâ‚™ := (aâ‚™ + bâ‚™) / 2
  
  -- Key fact: x must be in [aâ‚™, bâ‚™] (nested intervals preserve the root)
  have x_in_interval : x âˆˆ Set.Icc aâ‚™ bâ‚™ := by
    sorry
  
  -- Therefore |xâ‚™ - x| â‰¤ (bâ‚™ - aâ‚™) / 2
  have bound_by_half_interval : |xâ‚™ - x| â‰¤ (bâ‚™ - aâ‚™) / 2 := by
    have hx_le_b : x â‰¤ bâ‚™ := x_in_interval.2
    have ha_le_x : aâ‚™ â‰¤ x := x_in_interval.1
    rw [abs_sub_le_iff]
    constructor
    Â· -- xâ‚™ - x â‰¤ (bâ‚™ - aâ‚™) / 2
      have : xâ‚™ = (aâ‚™ + bâ‚™) / 2 := rfl
      linarith
    Â· -- -(bâ‚™ - aâ‚™) / 2 â‰¤ xâ‚™ - x
      have : xâ‚™ = (aâ‚™ + bâ‚™) / 2 := rfl
      linarith
  
  -- Use intervalLength_bisectionInterval: bâ‚™ - aâ‚™ = (bâ‚€ - aâ‚€) / 2^n
  sorry

end Numerical